<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>win10集成多个源的powershell包管理功能</title>
      <link href="/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/Win10PowerShell%E9%9B%86%E6%88%90%E5%8C%85%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD.html"/>
      <url>/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/Win10PowerShell%E9%9B%86%E6%88%90%E5%8C%85%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD.html</url>
      <content type="html"><![CDATA[<p>一直以来，在众多Linux系统的发行版以及一些开发语言都会集成一些包管理工具。</p><p>而Windows系统却没有官方的包管理工具，比较著名的第三方开源包管理工具是<a href="https://chocolatey.org/" target="_blank" rel="noopener">chocolatey</a>，上面的包一般也都比较全面，版本比较新。</p><p>win10之后这一状况得到了改善，在新版win10中PowerShell中具备了名叫<a href="https://github.com/OneGet/oneget" target="_blank" rel="noopener">OneGet</a>包管理的功能，并且该模块在GitHub上是开源的。</p><p>但是笔者大概试了一下，其自带的软件源还是比较少的，比如maven，spring这些常用的包都无法直接获取安装到，于是研究了一下，发现OneGet可以集成其他一些比较知名的软件源，这其中就包括chocolatey，研究了一下OneGet的命令<a href="https://github.com/OneGet/oneget/wiki/cmdlets" target="_blank" rel="noopener">wiki上的cmdlets命令</a>。将方法写了下来：</p><ol><li><p>首先是<code>win+x</code>,管理员运行PowerShell</p></li><li><p>如果之前没有集成该工具可以运行<code>Install-Module PackageManagement –Force</code>来安装</p></li><li><p>接下来输入<code>Find-PackageProvider</code>来寻找可用软件包的源，我们看到Chocolatey就在其中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; Find-PackageProvider</span><br><span class="line"></span><br><span class="line">Name                           Version          Source           Summary</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">nuget                          <span class="number">2.8</span>.<span class="number">5.208</span>        https://onege... NuGet provider <span class="keyword">for</span> the OneGet meta-package manager</span><br><span class="line">psl                            <span class="number">1.0</span>.<span class="number">0.210</span>        https://onege... psl provider <span class="keyword">for</span> the OneGet meta-package manager</span><br><span class="line">chocolatey                     <span class="number">2.8</span>.<span class="number">5.130</span>        https://onege... ChocolateyPrototype provider <span class="keyword">for</span> the OneGet meta-pa...</span><br><span class="line">PowerShellGet                  <span class="number">2.0</span>.<span class="number">4</span>            PSGallery        PowerShell module with commands <span class="keyword">for</span> discovering, in...</span><br><span class="line">DockerMsftProvider             <span class="number">1.0</span>.<span class="number">0.6</span>          PSGallery        PowerShell module with commands <span class="keyword">for</span> discovering, in...</span><br><span class="line">ChocolateyGet                  <span class="number">1.0</span>.<span class="number">0.1</span>          PSGallery        An PowerShell OneGet provider that discovers packag...</span><br><span class="line">DockerProvider                 <span class="number">0.0</span>.<span class="number">0.3</span>          PSGallery        PowerShell module with commands <span class="keyword">for</span> discovering, in...</span><br><span class="line">ContainerImage                 <span class="number">0.6</span>.<span class="number">4.0</span>          PSGallery        This is a PackageManagement provider module which h...</span><br><span class="line">NanoServerPackage              <span class="number">1.0</span>.<span class="number">1.0</span>          PSGallery        A PackageManagement provider to  Discover, Save and...</span><br><span class="line">GitLabProvider                 <span class="number">1.3</span>.<span class="number">8</span>            PSGallery        GitLab PackageManagement provider</span><br><span class="line">DockerMsftProviderInsider      <span class="number">1.0</span>.<span class="number">0.2</span>          PSGallery        PowerShell module with commands <span class="keyword">for</span> discovering, in...</span><br><span class="line">GitHubProvider                 <span class="number">0.5</span>              PSGallery        GitHub-as-a-Package - PackageManagement PowerShell ...</span><br><span class="line">GistProvider                   <span class="number">0.6</span>              PSGallery        Gist-as-a-Package - PackageManagement  PowerShell P...</span><br><span class="line">TSDProvider                    <span class="number">0.2</span>              PSGallery        PowerShell PackageManager provider to search &amp; inst...</span><br><span class="line">OfficeProvider                 <span class="number">1.0</span>.<span class="number">0.1</span>          PSGallery        OfficeProvider allows users to install Microsoft Of...</span><br><span class="line"><span class="number">0</span>install                       <span class="number">2.16</span>.<span class="number">3</span>           PSGallery        OneGet Package Provider <span class="keyword">for</span> Zero Install</span><br><span class="line">AppxGet                        <span class="number">0.1</span>.<span class="number">0.1</span>          PSGallery        Powershell Package Management (OneGet) Provider for...</span><br><span class="line">MyAlbum                        <span class="number">0.1</span>.<span class="number">2</span>            PSGallery        MyAlbum provider discovers the photos <span class="keyword">in</span> your remot...</span><br><span class="line">WSAProvider                    <span class="number">1.0</span>.<span class="number">0.4</span>          PSGallery        Provider to Discover, Install and inventory windows...</span><br><span class="line">Pacman-Provider                <span class="number">0.0</span>.<span class="number">1</span>            PSGallery        Pacman provider enables installation of pacman pack...</span><br><span class="line">ChocoOneGet                    <span class="number">0.4</span>.<span class="number">0</span>            PSGallery        OneGet provider <span class="keyword">for</span> Chocolatey</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>输入<code>Install-PackageProvider –Name &quot;chocolatey&quot;</code>来安装该软件包源（注名称不加引号也可以，其他选项参见命令wiki），也可以一次多安装几个其他的软件源</p></li><li><p>此时执行<code>Find-Package -Name maven</code>发现可以搜索到Choco上的包了，执行安装命令便自动获取安装了</p></li></ol><p>这样就大功告成，我们也实现了windows上使用官方的包管理工具，通过命令的方式方便管理很多开源和第三方的软件包，省去了通过浏览器去官网下载安装，再配置环境和注册表这些恼人的步骤😀。</p>]]></content>
      
      <categories>
          
          <category> 知识手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Win10 </tag>
            
            <tag> PowerShell </tag>
            
            <tag> Chocolatey </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二进制兼容性研究</title>
      <link href="/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%BC%E5%AE%B9%E6%80%A7%E7%A0%94%E7%A9%B6.html"/>
      <url>/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%BC%E5%AE%B9%E6%80%A7%E7%A0%94%E7%A9%B6.html</url>
      <content type="html"><![CDATA[<blockquote><p>软件中不同模块动态链接库的调用是常见现象。假设有模块A调用到了模块B，而B的代码进行了改动，这个时候B编译出来的dll文件，在A不进行重编的情况下，还能够直接被A调用而不出现异常吗？</p></blockquote><h2 id="一、几种兼容类型"><a href="#一、几种兼容类型" class="headerlink" title="一、几种兼容类型"></a>一、几种兼容类型</h2><ul><li><p>二进制兼容（Binary compatibility）</p><p>  程序针对其依赖模块的正确加载和运行</p></li><li><p>源代码兼容（Source compatibility）</p><p>  源码所依赖的模块在编译时不发生改变</p></li><li><p>行为兼容（behaviourcompatible）和Bug兼容（bugcompatible）</p><ul><li>程序表现与其他模块相同</li><li>上面情况包含Bug表现的扩展</li></ul></li></ul><p>后两种兼容情况这里先不讨论，那么二进制兼容与源代码兼容具体来说是怎么回事呢，二者之间又有什么关系呢？</p><p>接着开头说，如果上面提到的B模块改动并编译之后，依赖它的A能继续正常调用B里面的东西，并且正常运行，那么我们说这种兼容情况是二进制兼容；如果A需要重新编一下才能保持正常调用运转，则称这种情况为源代码兼容。</p><p>实际工作中开发一般很难察觉到这种细微的差异，因为底层模块被改了以后，在IDE启动运行的时候会检测到B重新生成了dll，这个时候A也会跟着重编去继承新dll的二进制接口。这也导致如果出现二进制兼容问题的时候，我们开发在IDE直接调试自测很难发觉其中的微妙差异。</p><p>但当程序部署之后新旧版本之间安装替换，一些公共模块对于上层依赖模块的二进制兼容问题便暴露出来了。比如我们计价程序Bin文件夹中的dll，每个地区版本均会带上，当后出的地区版本安装时路径下已经有了较老的其他地区版本，Bin文件夹中的dll便会被替换。这个时候就出现了老的上层模块在没有重编的情况下调用较新依赖模块的情况，也就是上面说到的二进制依赖所出现的场景。</p><h2 id="二、如何保证二进制兼容"><a href="#二、如何保证二进制兼容" class="headerlink" title="二、如何保证二进制兼容"></a>二、如何保证二进制兼容</h2><p>那么在修改代码的时候怎么能保障二进制的安全呢？</p><h3 id="1-允许的修改方法"><a href="#1-允许的修改方法" class="headerlink" title="1.允许的修改方法"></a>1.允许的修改方法</h3><pre><code>* 增加非虚函数，增加signal/slots，构造函数什么的。* 增加枚举enum或增加枚举中的项目。* 重新实现在父类里定义过的虚函数 (就是从这个类往上数的第一个非虚基类），理论上讲，程序还是找那个基类要这个虚函数的实现，而不是找你新写的函数要，所以是安全的。但是这可不怎么保准儿，尽量少用。      o 有一个例外: C++有时候允许重写的虚函数改变返回类型，在这种情况下无法保证二进制兼容。* 修改内联函数，或者把内联函数改成非内联的。这也很危险，尽量少用。* 去掉一个私有非虚函数。如果在任何内联函数里用到了它，你就不能这么干了。* 去掉私有的静态成员。同样，如果内联函数引用了它，你也不能这么干。* 增加私有成员。* 修改函数参数的缺省值。* 增加新类。* 对外开放一个新类。* 增减类的友元声明。* 修改保留成员的类型。* 把原来的成员位宽扩大缩小，但扩展后不得越过边界（char和bool不能过8位界，short不能过16位界，int不过32位界，以此类推）这个也接近闹残：原来没用到的那么几个位我扩来扩去当然没问题，可是这样实在是不让人放心。</code></pre><h3 id="2-禁止的修改方法"><a href="#2-禁止的修改方法" class="headerlink" title="2.禁止的修改方法"></a>2.禁止的修改方法</h3><pre><code>* 对于已经存在的类：      o 本来对外开放了，现在想收回来不开放      o 改变父类 (增加父类，减少父类，重新给父排序).* 对于类模板来说：      o 修改任何模板参数（增减或改变顺序）* 对于函数来说：      o 不再对外开放      o 彻底删掉      o 改成内联的(把代码从类定义外头移到头文件的类定义里头也算改内联)。      o 改变函数特征串：            + 修改参数，包括增减参数或函数甚至是成员函数的const/volatile描述符。如果一定要这么干，增加一个新函数吧。            + 把private改成protected或者public。如果一定要这么干，增加一个新函数吧。            + 对于非成员函数，如果用extern &quot;C&quot;声明了，可以很小心地增减函数参数而不破坏二进制兼容。* 对于虚成员函数来说：      o 给没虚函数或者虚基类的类增加虚函数      o 修改有别的类继承的基类      o 修改虚函数的前后顺序      o 如果一个函数不是在往上数头一个非虚基类中声明的，覆盖它会造成二进制不兼容。      o 如果虚函数被覆盖时改变了返回类型，不要修改它。* 对于非私有静态函数和非静态的非成员函数：      o 改成不开放的或者删除      o 修改类型或者const/violate* 对于非静态成员函数:      o 增加新成员      o 给非静态成员重新排序或者删除      o 修改成员的类型, 有个例外就是修改符号：signed/unsigned改来改去，不影响字节长度。</code></pre><h3 id="3-错误方法的分析"><a href="#3-错误方法的分析" class="headerlink" title="3.错误方法的分析"></a>3.错误方法的分析</h3><h4 id="取消导出或移除一个类"><a href="#取消导出或移除一个类" class="headerlink" title="取消导出或移除一个类"></a>取消导出或移除一个类</h4><p>改前 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KDECORE_EXPORT</span> <span class="title">KUrl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KUrl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因: 上面类的符号没有加入到生成的库的导出符号列表中，因此其他库或应用不能看见它们。</p><h4 id="改变类的继承层级"><a href="#改变类的继承层级" class="headerlink" title="改变类的继承层级"></a>改变类的继承层级</h4><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass1, <span class="keyword">public</span> BaseClass2</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass, <span class="keyword">public</span> OtherBaseClass</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass2, <span class="keyword">public</span> BaseClass1</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因：类中成员变量的大小或（和）顺序改变了，引起已有代码执行时分配过多或过少的内存，在错误的偏移位置来读写数据。</p><h4 id="改变模版类的模版参数"><a href="#改变模版类的模版参数" class="headerlink" title="改变模版类的模版参数"></a>改变模版类的模版参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/ GCC mangling before: _Z3foo15MyTemplateClassIiE</span><br><span class="line"><span class="comment">//              after: _Z3foo15MyTemplateClassIivE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(MyTemplateClass&lt;<span class="keyword">int</span>&gt;)</span></span>;</span><br></pre></td></tr></table></figure><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTemplateClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 = <span class="keyword">void</span>&gt;</span><br><span class="line">class MyTemplateClass</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因：与这个模板类型相关的函数，因为它的模板扩展改变也发生了变化。这会同时发生在函数（例如构造函数）以及将其作为参数的函数上。</p><h4 id="取消函数的导出"><a href="#取消函数的导出" class="headerlink" title="取消函数的导出"></a>取消函数的导出</h4><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Q_CORE_EXPORT <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">qVersion</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">namespace</span> KSocketFactory </span><br><span class="line">&#123;</span><br><span class="line">true<span class="function">KDECORE_EXPORT QTcpSocket *<span class="title">connectToHost</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">qVersion</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> KSocketFactory </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QTcpSocket *<span class="title">connectToHost</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：上面函数的符号没有加入到生成的库的导出符号列表中，因此其他库或应用不能看见它们。</p><h4 id="改为内联函数"><a href="#改为内联函数" class="headerlink" title="改为内联函数"></a>改为内联函数</h4><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the following could be in a .cpp</span></span><br><span class="line"><span class="keyword">int</span> Math::square(<span class="keyword">int</span> n)</span><br><span class="line">&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the following could be in a .cpp</span></span><br><span class="line"><span class="keyword">int</span> Math::square(<span class="keyword">int</span> n)</span><br><span class="line">&#123; <span class="keyword">return</span> n * n; &#125;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the following could be in a .cpp</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Math::square(<span class="keyword">int</span> n)</span><br><span class="line">&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因：当一个函数被声明为内联，并且编译器在它的调用点内联它时，编译器就不需要发送一份离线拷贝（out-of-line copy）。存在并调用此函数的代码将无法再解析该函数。另外，在GCC用-fvisibiliinlines-hidden编译时，如果编译器确实发出了一份离线拷贝，那么它将被隐藏（不添加到导出的符号表中），因此不能从其他库中被访问。</p><h4 id="改变函数的参数"><a href="#改变函数的参数" class="headerlink" title="改变函数的参数"></a>改变函数的参数</h4><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingii</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXHH@Z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingii</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXHH@Z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingRi</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXABH@Z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> &amp;i1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> i1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingPc</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXPAD@Z (32-bit)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingis</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXHF@Z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">short</span> i2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingiii</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXHHH@Z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> i3 = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingRKi</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXAAH@Z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i1)</span></span>; <span class="comment">// breaks with Sun CC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingPKc</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXPBD@Z (32-bit)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>原因：改变一个函数的参数（添加新的或改变现有的）改变了这个函数的名称。这是因为C++允许函数通过具有相同修饰别名，但稍微不同的参数来实现重载的机制所决定的。<br>上面的示例在SunCC中，没有一个修饰别名，编译器在声明和实现中都强制执行了一致的<a href="https://baike.baidu.com/item/pod/13976179" target="_blank" rel="noopener">POD</a>类型。</p><h4 id="改变返回类型"><a href="#改变返回类型" class="headerlink" title="改变返回类型"></a>改变返回类型</h4><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCC mangling: _Z8positionv</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?position@@YA_JXZ</span></span><br><span class="line"><span class="function">qint64 <span class="title">position</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z4namev</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?position@@YAVQByteArray@@DXZ</span></span><br><span class="line"><span class="function">QByteArray <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z4namev</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?position@@YAPBDXZ</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z12createDevicev</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?createDevice@@YAPAVQTcpSocket@@XZ</span></span><br><span class="line"><span class="function">QTcpSocket *<span class="title">createDevice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _ZNK10QByteArray2atEi</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?at@QByteArray@@QBA?BDH@Z</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> QByteArray::at(<span class="keyword">int</span>) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _ZN6QEvent17registerEventTypeEi</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?registerEventType@QEvent@@QAAXH@Z</span></span><br><span class="line"><span class="keyword">int</span> QEvent::registerEventType(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCC mangling: _Z8positionv</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?position@@YAHXZ</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">position</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z4namev</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?position@@YAVQString@@XZ</span></span><br><span class="line"><span class="function">QString <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z4namev</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?position@@YAVQString@@XZ</span></span><br><span class="line"><span class="function">QString <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z12createDevicev (unchanged)</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?createDevice@@YAPAVQIODevice@@XZ</span></span><br><span class="line"><span class="function">QIODevice *<span class="title">createDevice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _ZNK10QByteArray2atEi (unchanged)</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?at@QByteArray@@QBADH@Z</span></span><br><span class="line"><span class="keyword">char</span> QByteArray::at(<span class="keyword">int</span>) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _ZN6QEvent17registerEventTypeEi (unchanged)</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?registerEventType@QEvent@@QAAXW4Type@V0@@@Z</span></span><br><span class="line">QEvent::Type QEvent::registerEventType(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>原因：更改返回类型会在一些编译器中改变函数名的名称（GCC明显没有对返回类型进行编码）。然而，即使修饰（mangling）没有改变，关于如何处理返回类型的约定也可能改变。<br>在上面的第一个例子中，返回类型从64位改为32位整型，这意味着在某些架构上，返回寄存器的上半部分可能包含垃圾。在第二个例子中，返回类型从QByteArray改为QString，这是两种不兼容的类型。<br>在第三个例子中，返回类型从一个简单的整数（<a href="https://baike.baidu.com/item/pod/13976179" target="_blank" rel="noopener">POD</a>）变成了QString——在这种情况下，编译器通常需要传递一个隐藏的隐式第一个参数，而这是不存在的。在这种情况下，由于试图引用不存在的隐式QString参数，调用该函数的现有代码很可能会崩溃。<br>第四例,返回类型变化从一种<a href="https://baike.baidu.com/item/pod/13976179" target="_blank" rel="noopener">POD</a>类型(int)到另一个(enum),这（枚举）也可以看作一个int。他们的调用次序在所有编译器中极有可能相同,然而符号名称的修饰改变了,这意味着调用将因为未知符号而失败。</p><h4 id="改变访问权限"><a href="#改变访问权限" class="headerlink" title="改变访问权限"></a>改变访问权限</h4><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">true<span class="comment">// GCC mangling: _ZN7MyClass11doSomethingEv</span></span><br><span class="line">true<span class="comment">// MSVC mangling: ?doSomething@MyClass@@IAAXXZ</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// GCC mangling: _ZN7MyClass11doSomethingEv (unchanged)</span></span><br><span class="line">true<span class="comment">// MSVC mangling: ?doSomething@MyClass@@QAAXXZ</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因：一些编译器在其修饰别名中对函数的保护类型进行编码。</p><h4 id="改变成员函数的const限定符"><a href="#改变成员函数的const限定符" class="headerlink" title="改变成员函数的const限定符"></a>改变成员函数的const限定符</h4><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// GCC mangling: _ZNK7MyClass9somethingEv</span></span><br><span class="line">true<span class="comment">// MSVC mangling: ?something@MyClass@QBAHXZ</span></span><br><span class="line">true<span class="function"><span class="keyword">int</span> <span class="title">something</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// GCC mangling: _ZN7MyClass9somethingEv</span></span><br><span class="line">true<span class="comment">// MSVC mangling: ?something@MyClass@QAAHXZ</span></span><br><span class="line">true<span class="function"><span class="keyword">int</span> <span class="title">something</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因：编译器将一个函数的常量（const）性编译进了函数的修饰别名中。他们这样做是因为C++标准允许通过修改常量修饰符来实现重载函数。</p><h4 id="改变全局数据类型"><a href="#改变全局数据类型" class="headerlink" title="改变全局数据类型"></a>改变全局数据类型</h4><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCC mangling: data (undecorated)</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?data@@3HA</span></span><br><span class="line"><span class="keyword">int</span> data = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// GCC mangling: _ZN7MyClass4dataE</span></span><br><span class="line">true<span class="comment">// MSVC mangling: ?data@MyClass@@2HA</span></span><br><span class="line">true<span class="keyword">static</span> <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCC mangling: data (undecorated)</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?data@@3FA</span></span><br><span class="line"><span class="keyword">short</span> data = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// GCC mangling: _ZN7MyClass4dataE</span></span><br><span class="line">true<span class="comment">// MSVC mangling: ?data@MyClass@@2FA</span></span><br><span class="line">true<span class="keyword">static</span> <span class="keyword">short</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因：一些编译器将全局数据的类型编译进其修饰别名中。特别要注意的是，一些编译器甚至会对在C中允许的简单数据类型进行处理，这意味着<code>extern &quot;C&quot;</code>限定符也会产生不同的影响。<br>即使“mangling”没有改变，改变类型也会改变数据的大小。这意味着访问全局数据的代码可能访问太多或太少字节。</p><h4 id="改变全局数据的const限定符"><a href="#改变全局数据的const限定符" class="headerlink" title="改变全局数据的const限定符"></a>改变全局数据的const限定符</h4><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MSVC mangling: ?data@@3HA</span></span><br><span class="line"><span class="keyword">int</span> data = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// MSVC mangling: ?data@MyClass@@2HA</span></span><br><span class="line">true<span class="keyword">static</span> <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">static</span> <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MSVC mangling: ?data@@3HB</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> data = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// MSVC mangling: ?data@MyClass@@2HB</span></span><br><span class="line">true<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// the compiler won't even create a symbol</span></span><br><span class="line">true<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> data = <span class="number">42</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因：一些编译器将全局数据的const限定符编码进了其修饰别名中。特别要注意的是，在类本身中声明的静态const值可以考虑为“内联”——也就是说，编译器不需要为值生成外部符号，因为所有的实现都肯定知道它。<br>即使对于那些没有对全局数据的const限定符进行编码的编译器，添加const也可能使编译器将该变量放置在只读的内存段中。试图写入的代码很可能会崩溃。</p><h4 id="将虚函数添加到类中"><a href="#将虚函数添加到类中" class="headerlink" title="将虚函数添加到类中"></a>将虚函数添加到类中</h4><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="keyword">int</span> i;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">j</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因：没有任何虚拟成员或基础的类肯定与C结构完全相同，这是因为它与该语言的兼容性（即<a href="https://baike.baidu.com/item/pod/13976179" target="_blank" rel="noopener">POD</a>结构）。在一些编译器上，他们以及基于其的结构体（类）也是<a href="https://baike.baidu.com/item/pod/13976179" target="_blank" rel="noopener">POD</a>结构。然而，只要有一个虚基或虚成员函数，编译器就可以自由地以C++的方式排列结构，这通常意味着在结构的开始或结束时插入一个隐藏的指针，指向该类的虚拟表（virtual table）。这就改变了结构中元素的大小和偏移量。</p><h4 id="在非叶子类中添加新的虚函数"><a href="#在非叶子类中添加新的虚函数" class="headerlink" title="在非叶子类中添加新的虚函数"></a>在非叶子类中添加新的虚函数</h4><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">virtual</span> ~MyClass();</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">virtual</span> ~MyClass();</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因:在一个非末端的类(也就是说,至少有一个类派生从这个类)中添加一个新的虚函数，改变了虚拟表的布局(虚拟表基本上是一个函数指针列表,指向在这类级别活跃的函数)。为了适应新的虚函数，编译器必须向该表添加一个新条目，但是现有的派生类不会知道它，也不会在它们的虚拟表中包含条目。</p><h4 id="改变虚函数声明的顺序"><a href="#改变虚函数声明的顺序" class="headerlink" title="改变虚函数声明的顺序"></a>改变虚函数声明的顺序</h4><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">virtual</span> ~MyClass();</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">virtual</span> ~MyClass();</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因：编译器将指针放置到实现虚函数的函数中，按照它们在类中的声明顺序。通过改变声明的顺序，虚拟表中的条目的顺序也发生了变化。</p><p>注意：顺序是从父类继承的，所以覆盖一个虚函数，将会按照父类的顺序分配条目。</p><h4 id="覆盖一个非主基类的虚函数"><a href="#覆盖一个非主基类的虚函数" class="headerlink" title="覆盖一个非主基类的虚函数"></a>覆盖一个非主基类的虚函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">virtual</span> ~PrimaryBase();</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondaryBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">virtual</span> ~SecondaryBase();</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> PrimaryBase, <span class="keyword">public</span> SecondaryBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true~MyClass();</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> PrimaryBase, <span class="keyword">public</span> SecondaryBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true~MyClass();</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因：这是一个棘手的案例。当处理带有虚函数表的类的多重继承时，编译器必须创建多个虚表来保证多态性的工作（也就是说，当你的MyClass对象存储在PrimaryBase或中的基指针时）。主基类的虚表与该类的虚表共享，因为它们在开始时具有相同的布局。但是，如果你覆盖了来自非主基类的虚函数，它与添加一个新的虚函数是相同的，因为主基类中没有这个名称的虚函数。</p><p>注意：这适用于任何多继承的情况，即使它不是一个直接继承。在上面的例子中，如果我们用MyOtherClass从MyClass派生出来的，同样的约束也是适用的。</p><h4 id="使用具有不同顶部地址的协变（covariant）返回来覆盖虚函数"><a href="#使用具有不同顶部地址的协变（covariant）返回来覆盖虚函数" class="headerlink" title="使用具有不同顶部地址的协变（covariant）返回来覆盖虚函数"></a>使用具有不同顶部地址的协变（covariant）返回来覆盖虚函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data1</span> &#123;</span> <span class="keyword">int</span> i; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Data1 *<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data0</span> &#123;</span> <span class="keyword">int</span> i; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex1</span>:</span> Data0, Data1 &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex2</span>:</span> <span class="keyword">virtual</span> Data1 &#123; &#125;;</span><br></pre></td></tr></table></figure><p>改前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="function">Complex1 *<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="function">Complex2 *<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因：这是另一个棘手的情况，比如上面的例子，也是出于同样的原因：编译器必须向虚表中添加第二个条目，就像添加了一个新的虚函数一样，这会改变虚表的布局并破坏派生类。<br>当从父类上覆盖一个虚函数返回与父类不同的类时，协变（covariant）调用就会发生（这是由C++标准所允许的，因此上面的代码是完全有效的，并且用BaseClass的p类型调用p-get（）将调用MyClass：：get）。如果像Complex1和Complex2一样，多派生的类型没有相同的顶部地址，那么编译器需要生成一个存根（stub）函数（通常称为“thunk”）来调整返回的指针的值。它将地址放在与其父在虚表中的虚函数对应的条目中。然而，它同时也返回新的顶部地址（top-address）来增加一个新的调用入口。</p><hr><h2 id="三、实际问题探索"><a href="#三、实际问题探索" class="headerlink" title="三、实际问题探索"></a>三、实际问题探索</h2><h3 id="1-内核调外壳的情况分析"><a href="#1-内核调外壳的情况分析" class="headerlink" title="1.内核调外壳的情况分析"></a>1.内核调外壳的情况分析</h3><blockquote><p>首先问题是因为软件的新版本Bin文件夹中模块的一处函数被改动（加了一个默认参数），新版本Bin文件夹中模块随着新版地区的安装会覆盖已有的老版本dll，这样当老版本地区模块工作的时候，调用Bin文件夹中对应模块的函数并没有重编，这就造成了二进制兼容问题。</p></blockquote><h4 id="A）问题分析复现"><a href="#A）问题分析复现" class="headerlink" title="A）问题分析复现"></a>A）问题分析复现</h4><img src="/知识手记/二进制兼容性研究/内核调外壳.png" title="内核调外壳"><p>原有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// outPutA 增加了一个默认参数 bChange</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>, <span class="keyword">bool</span> bChange = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先看复现问题情况的Demo，复现原有未改动时的调用情形：</p><img src="/知识手记/二进制兼容性研究/原组合.png" title="原有问题现象"><p>接下来是有问题的改动方法的执行现象：</p><img src="/知识手记/二进制兼容性研究/加默认参数后.png" title="原有问题现象"><p>用IDA分析工具查看编译出的dll文件，其修饰别名以及对应的偏移信息：</p><p>原有</p><img src="/知识手记/二进制兼容性研究/原组合修饰别名及偏移信息.png" title="原组合修饰别名及偏移信息"><p>改后</p><img src="/知识手记/二进制兼容性研究/加默认参数后的修饰别名及偏移信息.png" title="加默认参数后的修饰别名及偏移信息"><p>我们可以看出，前后两个dll在<code>outputA</code>函数的修饰别名已经不一样了，同时看后面的解析信息，改后参数已经加了一个bool类型的参数。</p><p>我们再看调用dll的EXE文件的对应信息（未重编）：</p><img src="/知识手记/二进制兼容性研究/EXE的修饰别名及偏移信息.png" title="EXE的修饰别名及偏移信息"><p>可见，exe文件中存的dll信息还是维持了原有版本的内容（很显然是这样的），这样当新版本覆盖了旧版dll文件以后，exe调用时便找不到对应的链接库位置，无法正常运行了。</p><p> <strong>这也就是上面说到的错误做法中的【改变函数的参数】里面增加默认参数这种情况，也是一定要注意避免的一种情况。</strong></p><h4 id="B）多种修改情况的探索"><a href="#B）多种修改情况的探索" class="headerlink" title="B）多种修改情况的探索"></a>B）多种修改情况的探索</h4><blockquote><p>问题出现了，那么我们怎么去修改它，能够达到既能维持二进制兼容性，又能最大限度地减少改动影响呢？</p></blockquote><p>显然在原有函数上直接加参数来实现目的的方法是不可行了，那么大概还可以通过下面几种情况来实现原有目的：</p><h5 id="Ⅰ-增加不同名多一个默认参数的函数被原函数调用"><a href="#Ⅰ-增加不同名多一个默认参数的函数被原函数调用" class="headerlink" title="Ⅰ.增加不同名多一个默认参数的函数被原函数调用"></a>Ⅰ.增加不同名多一个默认参数的函数被原函数调用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 新增了一个不同名函数来实现目的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutC</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>, <span class="keyword">bool</span> bChange = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutA : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原函数调用了新增函数</span></span><br><span class="line">    outPutC(i, strName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseDll::outPutC(<span class="keyword">int</span> i, QString strName, <span class="keyword">bool</span> bChange)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutC : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; bChange &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><img src="/知识手记/二进制兼容性研究/增加不同名多一个默认参数的函数被原函数调用.png" title="增加不同名多一个默认参数的函数被原函数调用"><p>显然，原有EXE文件里面并没有新增函数的信息，调用dll中原有函数走到新增的函数时，便出现异常终止运行。</p><h5 id="Ⅱ-增加不同名多一个默认参数的函数不被原函数调用"><a href="#Ⅱ-增加不同名多一个默认参数的函数不被原函数调用" class="headerlink" title="Ⅱ.增加不同名多一个默认参数的函数不被原函数调用"></a>Ⅱ.增加不同名多一个默认参数的函数不被原函数调用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 新增了一个不同名函数来实现目的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutC</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>, <span class="keyword">bool</span> bChange = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutA : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseDll::outPutC(<span class="keyword">int</span> i, QString strName, <span class="keyword">bool</span> bChange)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutC : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; bChange &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><img src="/知识手记/二进制兼容性研究/增加不同名多一个默认参数的函数不被原函数调用.png" title="增加不同名多一个默认参数的函数不被原函数调用"><p>可见，原有函数不论参数，顺序还是执行内容都没有被改动，所以执行情况正常，能够实现二进制兼容。</p><h5 id="Ⅲ-增加多一个默认参数被调用的同名函数"><a href="#Ⅲ-增加多一个默认参数被调用的同名函数" class="headerlink" title="Ⅲ.增加多一个默认参数被调用的同名函数"></a>Ⅲ.增加多一个默认参数被调用的同名函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 新增同名函数来实现目的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>, <span class="keyword">bool</span> bChange = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutA : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原函数调用新增函数</span></span><br><span class="line">    outPutA(i, strName, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName, <span class="keyword">bool</span> bChange)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutC : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; bChange &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><img src="/知识手记/二进制兼容性研究/增加多一个默认参数被调用的同名函数.png" title="增加多一个默认参数被调用的同名函数"><p>根据程序输出情况，可见EXE调用原有函数，执行到调用新增同名函数时，由于没有新增函数的修饰别名和偏移信息，出现了循环调用自己的情况。</p><h5 id="Ⅳ-增加多一个默认参数不被调用的同名函数"><a href="#Ⅳ-增加多一个默认参数不被调用的同名函数" class="headerlink" title="Ⅳ.增加多一个默认参数不被调用的同名函数"></a>Ⅳ.增加多一个默认参数不被调用的同名函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 新增一个同名函数来实现目的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>, <span class="keyword">bool</span> bChange = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutA : "</span> &lt;&lt; i &lt;&lt; strName&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName, <span class="keyword">bool</span> bChange)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutC : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; bChange &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><img src="/知识手记/二进制兼容性研究/增加多一个默认参数不被调用的同名函数.png" title="增加多一个默认参数不被调用的同名函数"><p>可见，因为两个函数内部没有相互影响，但具有相同的调用特征，由于原EXE并没有新函数的信息，所以新增函数并不会对两者间的二进制兼容造成影响：</p><ul><li>函数能正常调用</li><li>IDE的代码界面提示调用函数，接口存在歧义</li><li>重编调用EXE模块，编译不通过</li></ul><p>虽然这样不影响模块间的二进制兼容，但最好还是不要这样做。（会影响重编时的代码兼容性）</p><h5 id="Ⅴ-增加多一个普通参数被调用的同名函数"><a href="#Ⅴ-增加多一个普通参数被调用的同名函数" class="headerlink" title="Ⅴ.增加多一个普通参数被调用的同名函数"></a>Ⅴ.增加多一个普通参数被调用的同名函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 新增一个同名非默认参数来实现目的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">bool</span> bChange, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutA : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原函数调用新增函数</span></span><br><span class="line">    outPutA(i, <span class="literal">false</span>, strName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, <span class="keyword">bool</span> bChange, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutC : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; bChange &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><img src="/知识手记/二进制兼容性研究/增加多一个普通参数被调用的同名函数.png" title="增加多一个普通参数被调用的同名函数"><p>这种情况与上面相近，EXE调用原有函数，走到调用新增函数的位置，识别成了调用原有函数自身。会将第二个参数转换为原函数的第二个参数（bool-&gt;String） ，转换出现异常，程序崩溃。</p><h5 id="Ⅵ-增加多一个普通参数不被调用的同名函数"><a href="#Ⅵ-增加多一个普通参数不被调用的同名函数" class="headerlink" title="Ⅵ.增加多一个普通参数不被调用的同名函数"></a>Ⅵ.增加多一个普通参数不被调用的同名函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 新增一个同名非默认参数函数来实现目的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">bool</span> bChange, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutA : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, <span class="keyword">bool</span> bChange, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutC : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; bChange &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><img src="/知识手记/二进制兼容性研究/增加多一个普通参数不被调用的同名函数.png" title="增加多一个普通参数不被调用的同名函数"><p>这种情况，原有函数没有调用新增函数，EXE执行时没有出现异常，二进制兼容能够得到保证；但是这样就违背了增加默认参数的初衷，适用场景被受到了限制。</p><h3 id="2-外壳调内核的情况分析"><a href="#2-外壳调内核的情况分析" class="headerlink" title="2.外壳调内核的情况分析"></a>2.外壳调内核的情况分析</h3><h4 id="A）问题场景"><a href="#A）问题场景" class="headerlink" title="A）问题场景"></a>A）问题场景</h4><p>同上面情况刚好相反，当出现外壳调用内核的场景时。往往会出现外壳多地区通用，而各地区内核版本不同的情形，这时候如何保证同一个外壳与多个版本的内核兼容就是需要考虑的问题了。</p><p>简而言之，当外壳与内核版本A调用时，执行我们希望的A方法；当与另一个版本B调用时，又能够正确的调用B对应的方法。</p><h4 id="B）方法探索"><a href="#B）方法探索" class="headerlink" title="B）方法探索"></a>B）方法探索</h4><p>这里我们采取的方法是，在外壳中做多一层级的接口集成，通过共有父接口，派生出接口A和B；同时不同版本的方法在其基础上派生出来，这样同一个方法在不同版本中会有不同的父接口A或B。调用的时候通过父接口实例化对象，判断动态转换为子接口的情况来分别调用对应的方法，达到上面场景的兼容目的。</p><img src="/知识手记/二进制兼容性研究/外壳调内核.png" title="外壳调内核"><p>以下是代码情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外壳实现位置</span></span><br><span class="line"></span><br><span class="line">DllTest::DllTest()</span><br><span class="line">&#123;</span><br><span class="line">    m_pBaseDll = <span class="keyword">new</span> BaseDll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DllTest::dllOutPut()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">dynamic_cast</span>&lt;IDllA*&gt;(m_pBaseDll))</span><br><span class="line">    &#123;</span><br><span class="line">        IDllA* dllA = <span class="keyword">dynamic_cast</span>&lt;IDllA*&gt;(m_pBaseDll);</span><br><span class="line">        dllA-&gt;outPut();</span><br><span class="line">        dllA-&gt;outPutA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">dynamic_cast</span>&lt;IDllB*&gt;(m_pBaseDll))</span><br><span class="line">    &#123;</span><br><span class="line">        IDllB* dllB = <span class="keyword">dynamic_cast</span>&lt;IDllB*&gt;(m_pBaseDll);</span><br><span class="line">        dllB-&gt;outPut();</span><br><span class="line">        dllB-&gt;outPutB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内核实现位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDllA</span> :</span> <span class="keyword">public</span> IBaseDll</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~IDllA() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDllB</span> :</span> <span class="keyword">public</span> IBaseDll</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~IDllB() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">declspec</span>(<span class="title">export</span>) <span class="title">BaseDll</span> :</span> <span class="keyword">public</span> IDllB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseDll();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IBaseDll interface</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPut</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当继承A接口时：</p><img src="/知识手记/二进制兼容性研究/外壳调内核A.png" title="外壳调内核A"><p>当继承B接口时：</p><img src="/知识手记/二进制兼容性研究/外壳调内核B.png" title="外壳调内核B"><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul><li>两种情况比较好的方案分别为：<ul><li>内核调外壳：增加不同名多一个默认参数的函数不被原函数调用</li><li>外壳调内核：判断动态转换派生的不同接口来判断该调用的方法</li></ul></li><li>另外：<ul><li>接口给了默认参数的情况下，继承函数不必再重复给默认参数，调用位置如果不给该参数传值，函数将优先采用接口参数，继承参数并不会起作用（某些IDE(Clion、VS等)中会在代码处给出警告提示）</li></ul></li></ul><blockquote><p><strong><em>参考文章:</em></strong></p><ul><li><a href="https://events.static.linuxfound.org/sites/events/files/slides/Binary_Compatibility_for_library_devs.pdf" target="_blank" rel="noopener">_Binary_Compatibility_for_library_devs_</a> </li><li><a href="https://community.kde.org/Policies/Binary_Compatibility_Issues_With_C%2B%2B" target="_blank" rel="noopener"><em>Binary Compatibility Issues With C++</em></a></li><li><a href="https://community.kde.org/Policies/Binary_Compatibility_Examples" target="_blank" rel="noopener">_Binary_Compatibility_Examples_</a> </li></ul></blockquote>]]></content>
      
      <categories>
          
          <category> 知识手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二进制兼容 </tag>
            
            <tag> Binary Compatibility </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++子类动态转父类同名函数的调用问题</title>
      <link href="/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/C++%E5%AD%90%E7%B1%BB%E5%8A%A8%E6%80%81%E8%BD%AC%E7%88%B6%E7%B1%BB%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98.html"/>
      <url>/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/C++%E5%AD%90%E7%B1%BB%E5%8A%A8%E6%80%81%E8%BD%AC%E7%88%B6%E7%B1%BB%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98.html</url>
      <content type="html"><![CDATA[<p>一直以来，重写、重载、隐藏一直都是C++中被经常讨论的基础知识点。</p><p>恰好最近遇到一个相关的问题，被人问到子类初始化的时候new出父类然后动态转换成子类，然后调用父类对象中的二者同名函数，会执行哪个。之前网上博客和讨论一般的集中在子类调用同名方法而非父，所以一时不得知晓准确情形。大概猜想转换后应该是调用父类的方法。</p><p>后被告知new出的是子类，执行的当然是子类的方法。</p><p>本着有问题写出来跑跑就知道了的想法，有空便大概写了一下跑跑这种情况。顺便又复习了一下三种技术的特征和知识点，<a href="https://blog.csdn.net/zx3517288/article/details/48976097" title="C++中重载、重写（覆盖）和隐藏的区别" target="_blank" rel="noopener">这篇文章</a>写的比较简明扼要，可以快速弄清三者知识区分。</p><h2 id="首先是讨论的那种情形："><a href="#首先是讨论的那种情形：" class="headerlink" title="首先是讨论的那种情形："></a>首先是讨论的那种情形：</h2><blockquote><p>隐藏：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A print!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B print!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a1 = <span class="keyword">dynamic_cast</span>&lt;A*&gt;(<span class="keyword">new</span> B());</span><br><span class="line">    a1-&gt;print1();</span><br><span class="line">    <span class="keyword">dynamic_cast</span>&lt;B*&gt;(a1)-&gt;print1();</span><br><span class="line"></span><br><span class="line">    A *a2 = (A*)(<span class="keyword">new</span> B());</span><br><span class="line">    a2-&gt;print1();</span><br><span class="line">    <span class="keyword">dynamic_cast</span>&lt;B*&gt;(a2)-&gt;print1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A <span class="built_in">print</span>!</span><br><span class="line">B <span class="built_in">print</span>!</span><br><span class="line">A <span class="built_in">print</span>!</span><br><span class="line">B <span class="built_in">print</span>!</span><br></pre></td></tr></table></figure><p>看来转换后的父对象并没有如上所说的执行子方法，不论是动态转换还是强转结果父对象都还是调用了父方法。</p><h2 id="于是试了另一种重写（覆盖）的情况："><a href="#于是试了另一种重写（覆盖）的情况：" class="headerlink" title="于是试了另一种重写（覆盖）的情况："></a>于是试了另一种重写（覆盖）的情况：</h2><blockquote><p>重写(覆盖)：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A print!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"virtual A print!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~B() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B print!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"virtual B print!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a1 = <span class="keyword">dynamic_cast</span>&lt;A*&gt;(<span class="keyword">new</span> B());</span><br><span class="line">    a1-&gt;print1();</span><br><span class="line">    <span class="keyword">dynamic_cast</span>&lt;B*&gt;(a1)-&gt;print1();</span><br><span class="line">    a1-&gt;print2();</span><br><span class="line">    <span class="keyword">dynamic_cast</span>&lt;B*&gt;(a1)-&gt;print2();</span><br><span class="line"></span><br><span class="line">    A *a2 = (A*)(<span class="keyword">new</span> B());</span><br><span class="line">    a2-&gt;print1();</span><br><span class="line">    <span class="keyword">dynamic_cast</span>&lt;B*&gt;(a2)-&gt;print1();</span><br><span class="line">    a2-&gt;print2();</span><br><span class="line">    <span class="keyword">dynamic_cast</span>&lt;B*&gt;(a2)-&gt;print2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A <span class="built_in">print</span>!</span><br><span class="line">B <span class="built_in">print</span>!</span><br><span class="line"><span class="keyword">virtual</span> B <span class="built_in">print</span>!</span><br><span class="line"><span class="keyword">virtual</span> B <span class="built_in">print</span>!</span><br><span class="line">A <span class="built_in">print</span>!</span><br><span class="line">B <span class="built_in">print</span>!</span><br><span class="line"><span class="keyword">virtual</span> B <span class="built_in">print</span>!</span><br><span class="line"><span class="keyword">virtual</span> B <span class="built_in">print</span>!</span><br></pre></td></tr></table></figure><p>可见，对于重写方法，直接对象调用不论怎么转换，调用的都是子类方法。</p><p>这也给自己启示，技术上的细节还是要多多学习，多多实践，毕竟实践出真知。</p>]]></content>
      
      <categories>
          
          <category> 知识手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 隐藏 </tag>
            
            <tag> 重写 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客中依赖Github评论功能的 Error Validation Failed 错误解决方法</title>
      <link href="/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E4%BE%9D%E8%B5%96Github%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%E7%9A%84%20Error%20Validation%20Failed%20%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html"/>
      <url>/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E4%BE%9D%E8%B5%96Github%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%E7%9A%84%20Error%20Validation%20Failed%20%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html</url>
      <content type="html"><![CDATA[<blockquote><p>最近有空把博客中的评论功能给完善了一下，结果发现用Gitalk时文章标题比较长的时候会出现Error Validation Failed错误。</p></blockquote><p>上项目讨论下查了有很多人都遇到了，这是因为基于Github评论的功能，最近Github限制了label长度，如果文章标题过长（总路径超过50字符）就会出现认证不通过，无法找到对应文章评论的错误。</p><p>网上也有一些讨论用MD5加密来缩短长度的方法，不过大多基于Jscript代码的，我用的maupassant主题页面用的pug写的，自己尝试了一下，照葫芦画瓢也给弄出来了，这里写出来，给同样需要的人，以免少走弯路。</p><p>具体修改..\themes\maupassant\layout_partial\comments.pug中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if theme.gitalk.enable == true</span><br><span class="line">    #container</span><br><span class="line">    link(rel=&apos;stylesheet&apos;, type=&apos;text/css&apos;, href=&apos;//unpkg.com/gitalk/dist/gitalk.css?v=&apos; + theme.version)</span><br><span class="line">    script(type=&apos;text/javascript&apos; src=&apos;//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&apos;)</span><br><span class="line">    script(type=&apos;text/javascript&apos; src=&apos;//unpkg.com/gitalk/dist/gitalk.min.js?v=&apos; + theme.version)</span><br><span class="line">    script.</span><br><span class="line">      var gitalk = new Gitalk(&#123;</span><br><span class="line">        clientID: &apos;#&#123;theme.gitalk.client_id&#125;&apos;,</span><br><span class="line">        clientSecret: &apos;#&#123;theme.gitalk.client_secret&#125;&apos;,</span><br><span class="line">        repo: &apos;#&#123;theme.gitalk.repo&#125;&apos;,</span><br><span class="line">        owner: &apos;#&#123;theme.gitalk.owner&#125;&apos;,</span><br><span class="line">        admin: [&apos;#&#123;theme.gitalk.admin&#125;&apos;],</span><br><span class="line">        id: md5(location.pathname),</span><br><span class="line">        distractionFreeMode: false</span><br><span class="line">      &#125;)</span><br><span class="line">      gitalk.render(&apos;container&apos;)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>script(type=’text/javascript’ src=’//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js’)</li><li>id: md5(location.pathname),</li></ul><p>是我自己改动的部分</p><p>谢谢，😀！</p>]]></content>
      
      <categories>
          
          <category> 知识手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Gitalk </tag>
            
            <tag> Error Validation Failed </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>忆往秋</title>
      <link href="/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/%E5%BF%86%E5%BE%80%E7%A7%8B.html"/>
      <url>/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/%E5%BF%86%E5%BE%80%E7%A7%8B.html</url>
      <content type="html"><![CDATA[<h5 id="王亚雷-2018-2-16"><a href="#王亚雷-2018-2-16" class="headerlink" title="王亚雷 2018.2.16"></a><em>王亚雷 2018.2.16</em></h5><p>夕有月兮，济济来去；</p><p>缘为何兮，与佳人遇；</p><p>风有暖兮，微拂我欲；</p><p>言潺潺兮，幸得重聚；</p><p>离未尽兮，念伊人趣；</p><p>心惴惴兮，欲又连系；</p><p>终如意兮，共佳缘续；</p><p>时之奔兮，不觉终剧；</p><p>木摇曳兮，万籁此寂；</p><p>枉男儿兮，恨不得句；</p><p>及归离兮，终达传意；</p><p>朝又暮兮，惶惶盼期；</p><p>得卿许兮，好不得意；</p><p>渺沧海兮，风雨同御；</p><p>衰须臾兮，甚惜时隙；</p><p>岁月流兮，业已婚即；</p><p>念及彼兮，暖暖感涕；</p><p>生老命兮，不离誓惜。</p>]]></content>
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爱情 </tag>
            
            <tag> 回忆 </tag>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>QtCreator设置英文字体之外的中文备选字体</title>
      <link href="/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/QtCreator%E8%AE%BE%E7%BD%AE%E8%8B%B1%E6%96%87%E5%AD%97%E4%BD%93%E4%B9%8B%E5%A4%96%E7%9A%84%E4%B8%AD%E6%96%87%E5%A4%87%E9%80%89%E5%AD%97%E4%BD%93.html"/>
      <url>/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/QtCreator%E8%AE%BE%E7%BD%AE%E8%8B%B1%E6%96%87%E5%AD%97%E4%BD%93%E4%B9%8B%E5%A4%96%E7%9A%84%E4%B8%AD%E6%96%87%E5%A4%87%E9%80%89%E5%AD%97%E4%BD%93.html</url>
      <content type="html"><![CDATA[<blockquote><p>QtCreator作为Qt默认的IDE一直以来用的还不错，尤其是最近更新版本之后加入了很多喜人的功能特性；用起来更加舒服顺手了。</p></blockquote><p>在目前最新的4.5版本更是加入并设置了Source Code Pro字体，于是自己有了个疑问：QtCreator 能不能像 VS Code 一样设置多个字体，第一字体覆盖不到的时候就会显示后面的字体。众所周知，Source Code Pro作为一种西文字体，没有中文，程序中写中文注释什么的IDE会调用默认的中文字体，也就是宋体，但是宋体在小字体下显示效果不如雅黑之类的字体清晰。</p><p>尝试了一下在IDE的 工具-设置 里面去设置字体，很遗憾里面只能设置一种字体，当设为英文字体后，代码中中文自动显示宋体 -_-！</p><p>后来，脑洞一开，能不能找到程序的配置文件手动设置两个字体？别说还真让我找到了！</p><h2 id="以下是设置文件的路径和设置方法："><a href="#以下是设置文件的路径和设置方法：" class="headerlink" title="以下是设置文件的路径和设置方法："></a>以下是设置文件的路径和设置方法：</h2><ul><li>QtCreator的设置路径在：…\AppData\Roaming\QtProject\QtCreator.ini 文件中；可以通过Ctrl+R然后键入AppData回车进入路径，然后一层一层找到QtCreator.ini；</li><li>打开文件，搜索设置选项，[TextEditor]；找到FontFamily，将等号后面的值改为”‘Source Code Pro’, Microsoft Yahei”；</li><li>保存关闭，重新打开QtCreator。</li></ul><p>大功告成，界面的汉字已经显示成了雅黑字体，更加容易阅读。😄</p><blockquote><p>注意：设置其他字体同样的道理在后面追加对应的内容即可；字体名称最好用英文，中文名称IDE有可能识别不理想。</p></blockquote><p>谢谢~</p>]]></content>
      
      <categories>
          
          <category> 知识手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QtCreator </tag>
            
            <tag> 代码字体 </tag>
            
            <tag> 中文字体 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>重装系统后恢复电脑未激活的预装office软件</title>
      <link href="/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8D%E7%94%B5%E8%84%91%E6%9C%AA%E6%BF%80%E6%B4%BB%E7%9A%84%E9%A2%84%E8%A3%85office%E8%BD%AF%E4%BB%B6.html"/>
      <url>/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8D%E7%94%B5%E8%84%91%E6%9C%AA%E6%BF%80%E6%B4%BB%E7%9A%84%E9%A2%84%E8%A3%85office%E8%BD%AF%E4%BB%B6.html</url>
      <content type="html"><![CDATA[<p>之前买了电脑，预装的win10家庭版，自己爱折腾就重装了个Pro的版本，可是当时太鲁莽，没有激活电脑预装自带的office2016家庭版软件。</p><blockquote><p>根据微软的预装激活逻辑，激活时会跟自己的账号绑定，之后不管怎么装直接登陆账号就可以下载安装激活了。</p></blockquote><p>但是自己没有激活，又时OEM的预装，也不知道产品密匙怎么办呢？上网找了一下方法，装同样的版本，下载office修复工具完全清除office信息，再重装对应的office家庭版本，再登陆就可以绑定账号，激活了。</p><p>激活后登陆微软网站，发现自己的账号名下已经有了对应版本office的产品授权了。大功告成😀！</p><h2 id="以下是详细方法和相关下下载链接："><a href="#以下是详细方法和相关下下载链接：" class="headerlink" title="以下是详细方法和相关下下载链接："></a>以下是详细方法和相关下下载链接：</h2><ul><li>第一步：系统还原到WIN10家庭中文版，并联网激活；<br>既然说到这里，那我给大家提醒一下，我看到很多人发帖问，WIN10 在线激活以后，只要你不换主板，随时联网都可以再次激活！（PS：此步非必须，如果电脑东西多不想还原，可以直接忽略，直接搜微软的简易修复工具下载运行，清理以下office残余数据就行了）。</li><li>第二步：<a href="http://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/zh-CN/HomeStudentRetail.img/" title="点击下载对应office版本" target="_blank" rel="noopener">下载OFFICE2016家庭和学生版</a>并安装；<br>安装完毕 打开程序，会要你填写账号密码，填写激活码，没有直接关闭进行下一步。确定以后，退出账号，退出程序！</li><li>第三步：<a href="http://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/zh-CN/HomeStudentRetail.img/" title="点击下载修复程序" target="_blank" rel="noopener">下载修复程序</a><br>打开软件 各种下一步直到结束；</li><li>第四步：再次打开OFFICE 你会发现提示此计算机包含OFFICE 直接输入账号，说明一下 OFFICE2016 是和你的账号绑定的，所以不要用别人的邮箱注册微软账号。</li></ul><p>此时激活成功!😄</p><p>顺便发一下 office家庭版 下载链接：</p><p><a href="http://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/zh-CN/HomeStudentRetail.img" target="_blank" rel="noopener">http://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/zh-CN/HomeStudentRetail.img</a></p><p>微软官方修复程序 下载链接：</p><p><a href="http://download.microsoft.com/download/F/2/2/F22D5FDB-59CD-4275-8C95-1BE17BF70B21/cssemerg97275.diagcab" target="_blank" rel="noopener">http://download.microsoft.com/download/F/2/2/F22D5FDB-59CD-4275-8C95-1BE17BF70B21/cssemerg97275.diagcab</a></p><p>下载链接直接复制在迅雷等下载软件里面粘贴下载就行了。</p>]]></content>
      
      <categories>
          
          <category> 知识手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Office </tag>
            
            <tag> 恢复预装 </tag>
            
            <tag> 永久激活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MFC中CtreeCtrl获取树节点数据的指针转换问题</title>
      <link href="/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/MFC%E4%B8%ADCtreeCtrl%E8%8E%B7%E5%8F%96%E6%A0%91%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%87%E9%92%88%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98.html"/>
      <url>/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/MFC%E4%B8%ADCtreeCtrl%E8%8E%B7%E5%8F%96%E6%A0%91%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%87%E9%92%88%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98.html</url>
      <content type="html"><![CDATA[<p>最近工作中遇到个问题，MFC中CTreeCtrl类的函数<code>GetItemData</code>。具体为返回值在类型转换后内部变量无法访问（内存无法读取）。</p><p>查找MSDN关与此函数的解释为</p><blockquote><p>CTreeCtrl::GetItemData</p><p><em>Visual Studio 2012</em> <em>调用该函数检索该32位特定的值与该指定的项目。</em></p><p>DWORD_PTR GetItemData(HTREEITEM hItem) const;</p><p>参数：</p><p>hItem-数据将检索项的句柄。</p><p>返回值：</p><p>32位特定的值与 hItem指定的项。 </p></blockquote><p>以下是示例代码: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HTREEITEM hmyItem = m_TreeCtrl.GetSelectedItem();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete all of the children of hmyItem whose item data is</span></span><br><span class="line"><span class="comment">// not equal to zero.</span></span><br><span class="line"><span class="keyword">if</span> (m_TreeCtrl.ItemHasChildren(hmyItem))</span><br><span class="line">&#123;</span><br><span class="line">   HTREEITEM hNextItem;</span><br><span class="line">   HTREEITEM hChildItem = m_TreeCtrl.GetChildItem(hmyItem);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (hChildItem != <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      hNextItem = m_TreeCtrl.GetNextItem(hChildItem, TVGN_NEXT);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (m_TreeCtrl.GetItemData(hChildItem) != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         m_TreeCtrl.DeleteItem(hChildItem);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      hChildItem = hNextItem;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又查找对应的<code>CTreeCtrl::SetItemData</code>MSDN解释如下：</p><blockquote><p>CTreeCtrl::SetItemData&gt;</p><p><em>Visual Studio 2012</em>  <em>调用此函数将32位特定的值与该指定的项目。</em> </p><p>BOOL SetItemData(<br>   HTREEITEM hItem,<br>   DWORD_PTR dwData<br>);</p><p>参数:</p><p>hItem-数据将检索项的句柄。<br>dwData-32位特定的值与 hItem指定的项。</p><p>返回值:</p><p>如果成功，非零;否则为0。 </p></blockquote><p>示例代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CString   str;</span><br><span class="line">HTREEITEM hItem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert 20 items into the tree control making every item's</span></span><br><span class="line"><span class="comment">// data be the handle of the item.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">   str.Format(TEXT(<span class="string">"item %d"</span>), i);</span><br><span class="line">   hItem = m_TreeCtrl.InsertItem(str);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (hItem != <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      m_TreeCtrl.SetItemData(hItem, (DWORD_PTR)hItem);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h2><ul><li><p>此函数返回值固定为32位或特定类型，Debug时应注意节点设置时的类型一致（<code>DWORD</code>或<code>DWORD_PTR</code>）。</p></li><li><p>若设置Data（<code>CTreeCtrl::SetItemData</code>）类型不正确会造成内存不能对齐，获取的结果内存无法访问。</p></li><li><p>调试时注意此问题，<code>SetItemData</code>与<code>GetItemData</code>应注意类型正确统一。</p></li></ul><blockquote><p>以后使用或者调试的时候需要额外注意，避免这个小问题在调试时耽误时间。</p><p>另外，17年春节刚过，祝自己和朋友们新年一切顺利。😆</p></blockquote>]]></content>
      
      <categories>
          
          <category> 知识手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> CTreeCtrl </tag>
            
            <tag> GetItemData </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决IE不能上网导致的一些软件无法登陆上网等问题</title>
      <link href="/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/%E8%A7%A3%E5%86%B3%E4%B8%80%E4%BA%9B%E8%BD%AF%E4%BB%B6%E6%97%A0%E6%B3%95%E7%99%BB%E9%99%86%E4%B8%8A%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
      <url>/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/%E8%A7%A3%E5%86%B3%E4%B8%80%E4%BA%9B%E8%BD%AF%E4%BB%B6%E6%97%A0%E6%B3%95%E7%99%BB%E9%99%86%E4%B8%8A%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
      <content type="html"><![CDATA[<h1 id="解决电脑上一些软件（LOL，360等）因为IE浏览器无法访问网络而不能登陆和加载网页的问题"><a href="#解决电脑上一些软件（LOL，360等）因为IE浏览器无法访问网络而不能登陆和加载网页的问题" class="headerlink" title="解决电脑上一些软件（LOL，360等）因为IE浏览器无法访问网络而不能登陆和加载网页的问题"></a>解决电脑上一些软件（LOL，360等）因为IE浏览器无法访问网络而不能登陆和加载网页的问题</h1><p>最近刚搬了新的住处，电脑遇到了一个问题，具体就是：</p><p>登陆英雄联盟发现不管哪个服务器都登陆不上去，检查网络质量也没有问题，TGP助手也能正常联网，开启游戏加速都不能解决。很是纠结，后来卸载重装也不能解决问题，路由器，网卡驱动，局域网配置都检查了一遍发现都正常，问题还是存在。</p><p>再后来发现360的软件管家也有同样的问题，在线的软件库无法加载，360安全卫士也无法登陆账号，点选里面的网络修复或者恢复设置都不能解决问题。</p><p>好吧，真是崩溃啊，完全找不到解决办法，在网上搜关于LOL联网的问题和360软件联网的问题，解决方法一大堆，然而都不能解决问题。😡</p><p>后来一个偶然的机会按照网上的方法配置Internet设置时发现 win10 里面不常用的IE浏览器也不能上网，然而别的浏览器都能正常上网。原因是不是这里呢？</p><p>查找了很多方法，找到了一个方法最终解决了问题，具体设置如下：</p><ul><li>在IE浏览器点 <em>设置-Internet选项-连接-局域网（LAN）设置-自动配置</em> 里面的 <em>自动检测设置</em> 前面点选打勾。确定退出，刷新页面，发现可以访问网络了。</li></ul><p>再进入之前无法登陆的游戏和软件，发现都能正常访问了。原来这些游戏的网络连接请求是走的IE的网络配置所以受到了影响。</p><blockquote><p>想想自己这几天到处找解决方法费了不少功夫。所以在这里把我的解决方法写下来，给有同样情况的朋友们提供个思路，尽量少走弯路解决问题。</p></blockquote><blockquote><p>谢谢😀</p></blockquote>]]></content>
      
      <categories>
          
          <category> 知识手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> IE </tag>
            
            <tag> 软件游戏登陆失败 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSharp使用独立线程函数结束阻塞对话窗体</title>
      <link href="/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/CSharp%E4%BD%BF%E7%94%A8%E7%8B%AC%E7%AB%8B%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E7%BB%93%E6%9D%9F%E9%98%BB%E5%A1%9E%E5%AF%B9%E8%AF%9D%E7%AA%97%E4%BD%93.html"/>
      <url>/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/CSharp%E4%BD%BF%E7%94%A8%E7%8B%AC%E7%AB%8B%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E7%BB%93%E6%9D%9F%E9%98%BB%E5%A1%9E%E5%AF%B9%E8%AF%9D%E7%AA%97%E4%BD%93.html</url>
      <content type="html"><![CDATA[<h1 id="多线程结束阻塞第三方对话窗体的方法"><a href="#多线程结束阻塞第三方对话窗体的方法" class="headerlink" title="多线程结束阻塞第三方对话窗体的方法"></a>多线程结束阻塞第三方对话窗体的方法</h1><p>最近用到了《Syncfusion Essential Studio》这个组件，这不是重点，重点是在用到 Grid 组件，想要将其导出为Excel文件时遇到了问题。</p><p>导出中组件会自己弹出一个阻塞的 MessageBox 对话窗口，窗口显示了遍历表格所用时间，标题为英文显得煞是突兀，由于直接引用的 .DLL 文件，无法将对话窗口的语句注释掉。</p><p>因为自己所用到的组件版本比较老，加之此东西比较生僻网上也很少有详实的参考资料，官网的开发文档也没找到设置取消的方法。</p><p>只能通过别的方法变通地解决这个不和谐的问题。网上找了下思路，觉得通过标题获取窗口句柄的方法来关闭窗口的方法比较合适。</p><p>以下是代码: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于找到MessageBox的句柄</span></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"user32.dll"</span>, EntryPoint = <span class="meta-string">"FindWindow"</span>, CharSet = CharSet.Auto)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">FindWindow</span>(<span class="params"><span class="keyword">string</span> lpClassName, <span class="keyword">string</span> lpWindowName</span>)</span>;</span><br><span class="line"><span class="comment">//关闭窗口 </span></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"user32.dll"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">EndDialog</span>(<span class="params">IntPtr hDlg, <span class="keyword">out</span> IntPtr nResult</span>)</span>;</span><br><span class="line">        <span class="comment">/*.....*/</span></span><br><span class="line">GridExcelConverterControl gridExcelContrl = <span class="keyword">new</span> GridExcelConverterControl();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    gridExcelContrl.GridToExcel(<span class="keyword">this</span>.Grid_BatchModify, fileName <span class="comment">/*,</span></span><br><span class="line"><span class="comment">        ConverterOptions.ColumnHeaders | ConverterOptions.RowHeaders*/</span>);</span><br><span class="line">    ptr = FindWindow(<span class="literal">null</span>, <span class="string">"窗口标题"</span>); <span class="comment">//查找MessageBox的弹出窗口,注意对应标题</span></span><br><span class="line">    EndDialog(ptr, <span class="keyword">out</span> result); <span class="comment">//查找到窗口关闭</span></span><br><span class="line">    MessageBox.Show(<span class="string">@"导出成功"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">@"导出失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    gridExcelContrl.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了🎉，小功告成，让我们来看看效果吧……欸？!😡怎么还是有呢？仔细一看，哈哈自己逗了，窗口出来的时候是阻塞状态，后面的销毁流程是无法执行的。</p><p>看来只能让销毁函数独立于对话窗口去销毁它了，于是换个思路，用独立的线程去关闭这个窗口，我们先做个销毁的线程，让它一直循环直到获取到窗口销毁然后退出执行。</p><p>程序如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于找到MessageBox的句柄</span></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"user32.dll"</span>, EntryPoint = <span class="meta-string">"FindWindow"</span>, CharSet = CharSet.Auto)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">FindWindow</span>(<span class="params"><span class="keyword">string</span> lpClassName, <span class="keyword">string</span> lpWindowName</span>)</span>; </span><br><span class="line"><span class="comment">//关闭窗口</span></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"user32.dll"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">EndDialog</span>(<span class="params">IntPtr hDlg, <span class="keyword">out</span> IntPtr nResult</span>)</span>;</span><br><span class="line">        <span class="comment">/*.....*/</span></span><br><span class="line">GridExcelConverterControl gridExcelContrl = <span class="keyword">new</span> GridExcelConverterControl();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread closeDlg = <span class="keyword">new</span> Thread(<span class="keyword">delegate</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        IntPtr ptr = IntPtr.Zero;</span><br><span class="line">        IntPtr result;</span><br><span class="line">        <span class="keyword">while</span> (ptr == IntPtr.Zero)    <span class="comment">//循环直到找到同标题的窗口</span></span><br><span class="line">            ptr = FindWindow(<span class="literal">null</span>, <span class="string">"窗口标题"</span>); <span class="comment">//查找MessageBox的弹出窗口,注意对应标题</span></span><br><span class="line">        EndDialog(ptr, <span class="keyword">out</span> result); <span class="comment">//查找到窗口则关闭</span></span><br><span class="line">    &#125;);</span><br><span class="line">    closeDlg.Start();</span><br><span class="line">    gridExcelContrl.GridToExcel(<span class="keyword">this</span>.Grid_BatchModify, fileName <span class="comment">/*,</span></span><br><span class="line"><span class="comment">        ConverterOptions.ColumnHeaders | ConverterOptions.RowHeaders*/</span>);</span><br><span class="line">    MessageBox.Show(<span class="string">@"导出成功"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">@"导出失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    gridExcelContrl.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完抓紧跑起来试试，哟嚯😁。可以了，这样一来导出的时候再也不会有烦人的英文窗口弹出来告诉你“导出用了0.00000000n秒”这件事了。</p><p>Ps：其实窗口还是存在过的，我们没法在内部跳过窗口创建的这一部，只是从外面结束掉而已，因为程序执行很快所以窗口几乎没有 show 出来就被终止掉了。</p><blockquote><p>另外文中<code>EndDialog</code>函数在有的时候也可以用<code>DestroyWindow</code>这个函数，根据需要终结的窗口类型去选用，不然可能会关闭不成功哦~</p></blockquote><blockquote><p>这就是我的方法，希望能抛砖引玉，给需要的朋友一点思路。</p></blockquote><blockquote><p>谢谢😄</p></blockquote>]]></content>
      
      <categories>
          
          <category> 知识手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> 软件 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>个人域名博客网站及域名邮箱搭建思路</title>
      <link href="/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%8F%8A%E5%9F%9F%E5%90%8D%E9%82%AE%E7%AE%B1%E6%90%AD%E5%BB%BA%E6%80%9D%E8%B7%AF.html"/>
      <url>/%E7%9F%A5%E8%AF%86%E6%89%8B%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%8F%8A%E5%9F%9F%E5%90%8D%E9%82%AE%E7%AE%B1%E6%90%AD%E5%BB%BA%E6%80%9D%E8%B7%AF.html</url>
      <content type="html"><![CDATA[<h2 id="2018年3月3日-更新"><a href="#2018年3月3日-更新" class="headerlink" title="2018年3月3日 更新"></a>2018年3月3日 更新</h2><p>经过漫长折腾，现已从<a href="http://jekyllrb.com/" title="Jekyll" target="_blank" rel="noopener">Jekyll</a>换为了<a href="https://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>,主题用的一个基于其的简约主题——<a href="https://github.com/tufu9441/maupassant-hexo" title="A simple Hexo template with great performance on different devices" target="_blank" rel="noopener">Maupassant</a>。</p><p>关于Hexo的教程就不再总结了，大同小异，这里有一篇非常详细的教程可以参考：<a href="https://www.jianshu.com/p/05289a4bc8b2" title="点击跳转" target="_blank" rel="noopener">如何搭建一个独立博客——简明Github Pages与Hexo教程</a>。</p><h1 id="我的个人域名博客及邮箱搭建方法"><a href="#我的个人域名博客及邮箱搭建方法" class="headerlink" title="我的个人域名博客及邮箱搭建方法"></a>我的个人域名博客及邮箱搭建方法</h1><blockquote><p>本文提供了我的个人网站及域名邮箱的建站思路，目前花费成本是26块钱，以后目测只需要维持域名的费用，也就是大概50以内每年的样子，喜欢的朋友可以做个参考。</p></blockquote><blockquote><p>其实网上这一类的文章很多，本人也是根据这些文章提供的思路和方法搭建的个人博客。也因此，我就不在这里列出详细的构建思路了，只是简要的写出自己的过程，如果有读者在别的地方搭建过程中遇到了问题，希望我的这些信息能为各位解决问题提供一点思路。</p></blockquote><blockquote><p>本文域名是从阿里云买的，解析什么的也都是直接用的<a href="https://www.aliyun.com/" title="阿里云" target="_blank" rel="noopener">阿里云</a>上面的，没有用第三方。域名邮箱用的是阿里云的免费版企业邮箱，最多50个账号，每个账号5G空间，2G网盘。网站模板用的是<a href="https://github.com/" title="Github" target="_blank" rel="noopener">Github</a>上的<a href="http://jekyllrb.com/" title="Jekyll" target="_blank" rel="noopener">Jekyll</a>，网站主题用的是基于Jekyll的<a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" title="Minimal Mistakes, a Jekyll Theme" target="_blank" rel="noopener">Minimal Mistakes</a>。</p></blockquote><h2 id="1-申请域名"><a href="#1-申请域名" class="headerlink" title="1.申请域名"></a>1.申请域名</h2><ul><li><p>首先，域名的注册网站，很多人选择了GoDaddy，或者国外的域名地址，我这个人比较懒，而且上去搜了一下发现上面没有“.wang”的域名。国内的找了一下发现<a href="https://www.aliyun.com/" title="阿里云" target="_blank" rel="noopener">阿里云</a>上面有，而且我名字拼音的域名还在——“yalei.wang”，最最主要的是才26块钱一年！！！果断买之。</p></li><li><p>买了域名以后，<a href="https://www.aliyun.com/" title="阿里云" target="_blank" rel="noopener">阿里云</a>上面有很多优惠及各种主机云服务等等，一般网站流量大，需求性能高点的可以考虑，作为免费党和自玩玩家，我是当然不会去花不必要的钱的🙄。</p></li><li><p>纵观整个建站过程，唯一逃不掉的花钱环节就是购买自己的域名， 除此之外大都可以用免费的来代替。</p></li></ul><h2 id="2-域名邮箱的开通"><a href="#2-域名邮箱的开通" class="headerlink" title="2.域名邮箱的开通"></a>2.域名邮箱的开通</h2><ul><li><p>这个比较简单，买完域名以后可以直接在阿里云上面用企业邮箱绑定域名。企业邮箱一般面向经营企业，所以要收费，当然也有免费版，只不过地址藏得比较小，不仔细找很难找到。我在这里直接给出各位地址——<a href="https://exmail.aliyun.com/free" title="阿里云企业邮箱免费版" target="_blank" rel="noopener">免费版企业邮箱</a></p></li><li><p>开通免费企业邮箱之后记住一定要及时绑定域名让它生效，据说七天内没有绑定会被收回，而且免费企业邮箱只能申请一回。</p></li><li><p>绑定域名及开通域名邮箱比较简单，毕竟是阿里自家的，在阿里云控制台一步一步按说明操作开通就可以了。（在这里不得不说一下，阿里云的强大，为我们省去了很多麻烦的工作👍）</p></li><li><p>另外说一点，我的<a href="http://yalei.wang/" title="王亚雷的个人博客">个人博客</a>因为是“.wang”的域名，很多域名邮箱不支持，这其中就包括腾讯邮箱，本来我是想省事把把所有邮箱集成到自己的QQ邮箱的。也不知道这是因为阿里自己的竞争手段呢，还是腾讯这些企业邮箱真的不支持这个后缀。不过本着阿里邮箱也没花什么钱，而且设置步骤很简单自动化，也就认了阿里的邮箱，就这么用了。</p></li></ul><h2 id="3-个人网站的开通"><a href="#3-个人网站的开通" class="headerlink" title="3.个人网站的开通"></a>3.个人网站的开通</h2><ul><li><p>首先，我用的是<a href="https://github.com/" title="Github" target="_blank" rel="noopener">Github</a>上的<a href="http://jekyllrb.com/" title="Jekyll" target="_blank" rel="noopener">Jekyll</a>，网站主题用的是基于Jekyll的<a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" title="Minimal Mistakes, a Jekyll Theme" target="_blank" rel="noopener">Minimal Mistakes</a>。<a href="https://pages.github.com/" title="GitHub Pages" target="_blank" rel="noopener">GitHub Pages</a>是Github上一个可以用来搭建个人网站或组织网站或项目主页的功能。详细介绍可以点开链接去了解。</p></li><li><p><a href="https://pages.github.com/" title="GitHub Pages" target="_blank" rel="noopener">GitHub Pages</a>可以用自带的生成选项生成简单的单网页，具体设置在项目页面的“Settings”选项里面。当然也可以用我用的<a href="http://jekyllrb.com/" title="Jekyll" target="_blank" rel="noopener">Jekyll</a>来做自己的网站，这个在github上有很多人在用，读者可以直接<a href="https://github.com/search?o=desc&amp;q=blog&amp;s=forks&amp;type=Repositories&amp;utf8=%E2%9C%93" title="Fork最多的Blog相关开源项目" target="_blank" rel="noopener">在github上面搜索blog然后选择按照fork数目排序</a>，这样前面几个基本上就是比较流行的博客搭建模板了。</p></li><li><p>模板主题我用的是<a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" title="Minimal Mistakes, a Jekyll Theme" target="_blank" rel="noopener">Minimal Mistakes</a>，这是一个简洁功能丰富的主题，同样在github上拥有不错的人气。具体使用方法，项目主页上介绍的非常详细了，大家可以直接fork到自己的空间直接修改构建自己的博客。</p></li><li><p>需要注意的一点是，github设定如果把项目的名称重命名为“username.github.io”网站会自动把当前项目生成的网页作为个人的网页空间，用户可以直接通过“username.github.io”来访问此网页。另外，这样设置的话，Github Pages会把Master分支设置成默认显示分支，且不能修改分支选项。如果读者不想把此网页作为”username.github.io”的访问页面，而只是打算把它作为一个二级页面，或是项目页面的话，读者可以把项目名称命名成别的名称，创建一个名字为”gh-pages”的分支来显示项目网页。</p></li></ul><h2 id="4-域名与Github-Pages的绑定"><a href="#4-域名与Github-Pages的绑定" class="headerlink" title="4.域名与Github Pages的绑定"></a>4.域名与Github Pages的绑定</h2><ul><li>首先需要设置的是阿里云里面的域名解析，其他地方购买的域名同理，网上也有详细的设置方法，以下贴出我自己的设置参数：</li></ul><table><thead><tr><th>记录类型</th><th>主机记录</th><th>解析线路</th><th>记录值</th><th>MX优先级</th></tr></thead><tbody><tr><td>CNAME</td><td>www</td><td>默认</td><td>rean1030.github.io</td><td>–</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>192.30.252.154</td><td>–</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>192.30.252.153</td><td>–</td></tr></tbody></table><ul><li><p>需要注意的是，如果不设置绑定自己的域名，读者可以直接通过“username.github.io”访问自己的网站，这样连域名的钱都省了。</p></li><li><p>第一条CNAME的设置在有的教程里面其中的记录值设成了跟下面一样的Github Pages IP地址，笔者亲测，这样设置，网页能够正常访问，但是在Github上项目的设置页面会有警告产生。并且每次提交生成网页后，会有一份警告邮件发送到用户的邮箱中。最好还是把CNAME设置成自己网页的对应地址比较好。</p></li><li><p>设置了自己的域名解析后，在Github自己对应的项目设置中找到“Github Pages”设置选项，找到“Custom domain”设置栏，将自己的域名填上去，这样之后，Github会自动在项目中创建CNAME的文件，同时将用户设置的域名写入。这样两边的CNAME解析对应上，Github上页面生成的警告就没有啦😀，我们会看到一条绿色的提示“ Your site is published at <a href="http://www.yalei.wang/”（www.yalei.wang是笔者的个人域名地址）。" target="_blank" rel="noopener">http://www.yalei.wang/”（www.yalei.wang是笔者的个人域名地址）。</a></p></li><li><p>另外还需要注意一点，如果读者不设置自己的域名绑定的话，Github会自动设置并转换网址为https安全链接；如果设置了个人网址绑定的话，该选项是无法选取的，也就是通过个人网址的链接只能走http链接。</p></li><li><p>此时所有的设置基本已经大功告成了，剩下的就是自己用自己方便的方法来修改项目上的配置文件来慢慢做出自己的网站来；每次提交变更后，Github会自动重新生成静态网页，读者可以自己到项目的设置里面看页面是否生成成功，如果失败上面也会有失败的原因及提示信息，同时会发送一封提示邮件到用户设置的邮箱中。</p></li></ul><blockquote><p>网站的搭建和调试是个费劲的事，读者可以参考笔者的网站来搭建自己的网站，我已经把网站模板的调试和界面汉化工作完成，想省事的朋友可以直接到我的项目下直接fork我的项目，在此基础上进行修改。以下是我项目的地址——<a href="https://github.com/Rean1030/rean1030.github.io" title="Blog of Wang Yalei" target="_blank" rel="noopener">点击跳转到我的项目地址</a></p></blockquote><blockquote><p>目前我的网站相关页面的内容和详细说明也在慢慢建设中，接下来我会写一篇手记来总结一下自己用<a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" title="Minimal Mistakes, a Jekyll Theme" target="_blank" rel="noopener">Minimal Mistakes</a>，搭建自己页面和布局过程中的一些需要注意的地方。顺便也会介绍以下自己的项目文件的布局和网站的界面功能，以方便参考的朋友直接修改，少走弯路。</p></blockquote><blockquote><p>今后的日子烦请大家多多关照😁，最后附上我的——<a href="http://yalei.wang" title="王亚雷的个人网站">个人网址</a>，谢谢。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 知识手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人域名 </tag>
            
            <tag> 个人博客 </tag>
            
            <tag> 域名邮箱 </tag>
            
            <tag> 个人网站 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>徐洪慈简传</title>
      <link href="/%E7%B2%BE%E9%80%89%E6%96%87%E6%91%98/%E5%BE%90%E6%B4%AA%E6%85%88%E7%AE%80%E4%BC%A0.html"/>
      <url>/%E7%B2%BE%E9%80%89%E6%96%87%E6%91%98/%E5%BE%90%E6%B4%AA%E6%85%88%E7%AE%80%E4%BC%A0.html</url>
      <content type="html"><![CDATA[<blockquote><p>提示：本文选自河南文艺出版社《31人说：我们的中国式人生》，转载自网易《人间》栏目。<br><cite><a href="http://renjian.163.com/16/0730/20/BT8HND27000153N3.html" title="中国版肖申克" target="_blank" rel="noopener">原文链接</a></cite></p></blockquote><blockquote><p>作者：奥永，徐洪慈的妻子；胡展奋，资深媒体人，著名记者、作家。</p></blockquote><img src="/精选文摘/徐洪慈简传/徐洪慈与故人重逢.jpg" title="1992年徐洪慈（中间）与故人重逢（右二为李光荣）"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>徐洪慈，曾是年轻的中共地下党员、医学院的高才生。1957年，他的命运突变，成为右派。为了洗刷清白，徐洪慈四次越狱，亡命天涯。一个人，十四年，逃跑四次，亡命三万里。当年大红大紫的大学生是怎么沦落为逃犯的？</p><h2 id="一张大字报收获“极右”"><a href="#一张大字报收获“极右”" class="headerlink" title="一张大字报收获“极右”"></a>一张大字报收获“极右”</h2><p>1958年冬，在安徽白茅岭农场，一年前还是上海第一医学院学生的徐洪慈，此刻已经接受了大半年的劳动改造。寒夜中，想起临行时学校说过的话，他偷偷给在上海的母亲写了一封信。</p><p>徐洪慈写信给母亲，要她到学校里找李书记，看是不是可以由学校出面把他要回来。因为当年学校说过，去改造的话，如果表现好，可以把他要回来，这话让徐洪慈听起来觉得很有理。所以，徐洪慈一直抱有期待，有一天自己还能回到校园。</p><p>然而，学校拒绝了他。</p><p>被拒绝以后，徐洪慈的母亲质问对方：“我们在国民党时代，把儿子培养成共产党员，为什么在你们手里又倒退成右派？是你的责任还是我们的责任？”</p><p>1933年，徐洪慈出生在上海一个买办的家庭，十五岁就参加了中共地下党，十八岁成为华东局青年干部，二十岁参加全国“青代会”，受到毛泽东、刘少奇等国家领导人的接见。二十一岁，他考入上海医学院。如果不是1957年的那场变化，他将成为一名医生，成为新中国急需的专业人才。</p><p>在同学们眼里，徐洪慈当年红得发紫，很多人都叫他“老前辈”。1957年，命运突然一个大转折。就像很多人感到突然一样，徐洪慈也觉得莫名其妙。</p><p>1957年4月，《人民日报》发表社论，鼓励大家“大鸣大放”，向党交心提意见。但是上海第一医学院的气氛并不热烈，没有人贴大字报。到了6月，医学院的副院长主持召开全体党、团干部大会，动员大家“大鸣大放”、贴大字报，并说第二天就要看到成效。</p><p>动员会后，徐洪慈回到宿舍，由十四个同学草拟了一份大字报，一共五十一条意见，第二天就贴出去了。</p><p>这五十一条意见，有的是对党的意见，有的是对学校和专业设置的意见。例如，希望大学多派一些其他国家的专家，不要仅仅派苏联专家，因为各国都有自己的学术精英；是不是不必只学俄语，可不可以选择学日语、英语、德语；文中也谈及，党内民主不够，党代会总是报喜不报忧。</p><p>1957年的6月6日，五十一条贴出来后，在学校内形成了一股贴大字报的热潮。6月6日，对徐洪慈来说是漫长的一天，也永远记在徐洪慈心里，五十一条变成了向党进攻、反党、反社会主义的证据。</p><p>苦闷的徐洪慈只有向女友倾诉。他告诉女友，自己已经被批判了，但是，他多说了两句话，第一句是：“到底是我正确还是毛泽东正确，三百年以后见分晓。”他说这句话时，指的是对苏联的态度，对苏联盲目崇拜。</p><p>他说的第二句话是：“如果我在这儿待不下去，我就想出国，无产阶级革命是不分国界的。”当时的出国就相当于叛国。</p><p>给他致命一击的，恰恰是他的女朋友把这两句话揭发了出来。当时右派分右倾、右、中右、极右。徐洪慈被定为极右中的极右，被开除党籍、学籍，也成为少数的被送进监狱的学生右派。</p><h2 id="三次越狱，获刑六年：一把勺子挖通了土墙"><a href="#三次越狱，获刑六年：一把勺子挖通了土墙" class="headerlink" title="三次越狱，获刑六年：一把勺子挖通了土墙"></a>三次越狱，获刑六年：一把勺子挖通了土墙</h2><p>1957年的经历常常会复现在徐洪慈的头脑中。一年之后，向学校求助的一线希望破灭了，徐洪慈动起了另外一个念头。他要自己回到五百公里外的家——上海。</p><p>1958年12月14日凌晨，徐洪慈和同伴从白茅岭逃了出来。</p><p>逃离监狱以后，他们走了很长一段路，然后坐长途汽车回到了上海。到上海后，徐洪慈给家里打电话，结果暴露了自己。在发现他们逃走以后，监狱马上行动，上海方面立刻对徐洪慈的家实施了监控。抓获以后，他被送回了白茅岭。</p><p>徐洪慈觉得自己被冤，心中积郁难平。多年后，他回忆说：</p><p>我就想不通，明明是他们号召我们写大字报的，还说不写是对党没感情，我后来才知道，这是“引蛇出洞”。</p><p>不甘心的徐洪慈，从白茅岭第二次出逃。</p><p>这一次，徐洪慈逃向了昆明，从昆明到泸水，他计划通过泸水越境到缅甸。泸水其实已经到了边境，但是根据原先老地图的记载，这里离边境还有很长的路。新中国成立以后地图改版了，他不知道，居然大模大样到食堂去吃咸肉菜饭，大吃一顿后还大摇大摆到理发店去理发。</p><p>徐洪慈的头发又乱又长，穿的衣服又脏又破，眼神也有点异样，在这么一个敏感的地方，这么一个敏感的时期，带着外地口音的陌生人，特别引人注目。于是，他在泸水落网，关押在泸水看守所。</p><p>尽管已经有过一次逃跑被抓回的经历，但此时的徐洪慈，依然不相信自己会在泸水看守所这个地方束手就擒。他有一种急切想证明自己的强烈冲动，强烈的自尊被激发起来：“我一定要用行动证明自己。”他想到国外继续参加革命，用行动来重新证明自己。</p><p>徐洪慈立即开始实施他的第三次逃跑计划。</p><p>泸水是一个偏僻落后的地方，看守所的墙虽然厚，却是并不坚固的土墙。徐洪慈决心在上面挖洞。他搞来了一把不锈钢勺子，上海人叫调羹，不断地挖，土挖不动，他就向墙上撒点小便，让它松软一下再挖，一次不行再来一次，挖出来的土就堆到床底下。</p><p>多次下来，他庆幸居然没人发现。粗糙却并不坚固的土墙，经不起勺子日复一日的刨挖，挖通的那一刹那到来了。</p><p>下面的一幕，是真实的，却极富戏剧性。当徐洪慈挖通了土墙，把手伸出去，正在兴奋之时，外面的一把叉子叉住了他的虎口。伸出的手被外面早已潜候多时的人牢牢地抓住。他所做的这一切，早已被发现，人家就等这一刻了。</p><p>一年之中三次越狱，辗转七千公里。徐洪慈不但没能证明自己的清白，反而“一错再错”。</p><p>1959年，美丽的中缅边境小城——云南泸水，逃跑的大学生右派徐洪慈正在接受着一场审判。法官宣判说：</p><p>你是非法越境。如果没有这次，第三次逃跑的话，可能会判得轻一点，更可能就是判得很轻。轻到什么程度呢？我们要用你，因为你是医生。</p><p>像我们边境落后的地方，太缺少你这样的人才了。你看，你懂多国外语，英语、德语、俄语，是不是？在我们这里是奇缺人才，你还学的是医疗专业，比我们这里所有医生强多了。你看看，你自己毁了自己，你想越狱，罪加一等。</p><p>就这样，徐洪慈被判六年。</p><h2 id="“你不就是逃跑吗？”"><a href="#“你不就是逃跑吗？”" class="headerlink" title="“你不就是逃跑吗？”"></a>“你不就是逃跑吗？”</h2><p>云南，遥望上海三千公里，逃，使徐洪慈离家越来越远，六年刑期宣判之后，他先后辗转到几个关押地，其中有丽江大盐农场和拉马古铜矿。</p><p>逃，也使他在别人的眼中越来越坏。“看看，就知识分子才有这种坏心思”，“多次逃跑，越狱成性”，“不服管教”……管教对他也没好话。而此时，徐洪慈遇到了王金如，这是在大盐农场。</p><p>徐洪慈没有想到，自己被“调”到王金如手下，居然是王金如把他“要”过去的。王金如说：“这个大学生脑子活，聪明，很多东西都懂。特别是他有医学的专长，为什么不能到我们医务室来工作呢？”就这样，暗地把他要了过去。</p><p>王金如个子不高，见面第一句话就打着哈哈：“好你个逃跑大学生，人家都说你是逃跑专家，我看你还可以啊，你罪不算大，你不就是逃跑吗？现在你跑不了了，在这里好好工作吧。”他直言不讳地告诉他，“是我把你要过来的”，并甩下几句话，“你到我们这医务室工作吧，发挥你的长处，我们缺的就是医生。”</p><p>在王金如手里，徐洪慈的工作环境很不错，王金如不歧视他，俩人很谈得来。但随着王金如调走，他身处的环境开始恶化。辗转了几个地方后，他被安排到最苦的拉马古铜矿。在这里，他遇到了另外一个管教队长梁满杞。</p><p>梁队长和他进行了一次很恳切的谈话。“很多人说你坏话，我看你不是。你只是处处有自己的思想，处处显得与众不同而已，就是这样。但是在别人眼里，你是一个不服管教的人。其实我不认为你是这样的人，我希望你在这里能够好好工作，让我证明我的判断是对的。”这一席话对徐洪慈有非常大的触动。</p><p>在梁满杞手下，徐洪慈从事的是地质队的工作，这意味着他能在矿区周围自由行动，和一般犯人还有区别。徐洪慈觉得这是一种知遇之恩，重新找回了被信任的感觉。他没有再动一次逃跑的念头。“我在他手里，六年就六年。”徐洪慈回忆说。</p><p>在王金如和梁满杞的感召下，徐洪慈安心服刑。六年里，他时常想到父母、同学，还有那个揭发他的女朋友。他们在做什么？</p><p>1965年，徐洪慈刑满了，他急切地想回家。</p><h2 id="就你这恶劣的态度，还想回家？"><a href="#就你这恶劣的态度，还想回家？" class="headerlink" title="就你这恶劣的态度，还想回家？"></a>就你这恶劣的态度，还想回家？</h2><p>刑满释放，应该可以回家。但当时的政策却不让徐洪慈回家。</p><p>监狱领导说：“你不能回家。想回上海？”</p><p>徐洪慈说：“我刑满回家是很正常的要求。”</p><p>“不行，就你这恶劣的态度，继续留场。”</p><p>于是，他变成“留场人员”，这是那个时代特有的一种人群，即刑满释放后，继续留在劳改农场从事劳动的人，有一些有限的自由，星期天可以上街去买点东西吃，每个月有为数很少的一点工资。当然，最大的不同，是自己有了一个可以独立睡觉的地方。</p><p>留场以后，徐洪慈的处境并不好，他被分到了管教木世勤的手下。木世勤对他很有偏见，徐洪慈也不服软。</p><p>一天半夜，木世勤还开着喇叭，吵得徐洪慈没法睡觉。当时，讲究喇叭的轰炸，对犯人进行思想改造。徐洪慈忍无可忍，冲到木世勤的楼下，说：“请你把喇叭关上好吗？我们睡不好的话，明天是没法工作的。”木世勤觉得，这不是公然向他叫板吗？所以“文革”一开始，徐洪慈的灾难就来临了。</p><p>1966年“文革”爆发后，他被第一批列入运动对象，运动不断升级，再升级。终于，他被判刑二十年。尽管徐洪慈逃跑已经按照他该受到的惩罚服过刑了，但这些经历再次被列入罪状。</p><p>这对他是一个无情的打击。徐洪慈觉得：“我再怎么好好地改造都是无效的，是没用的。”“我再怎么听话也是没用的。”</p><p>那时候，公判大会的形式时常被采用，以起到“震慑”作用。在丽江民主广场的万人公判大会上，他被五花大绑，游街示众，甚至被踢、打、枪托砸。徐洪慈永远也忘不了那一幕幕。</p><p>徐洪慈开始绝望了。刑满释放三年零七个月后，他接到报信，形势对他非常不利，并且有生命危险。</p><h2 id="重刑犯监狱长对他“早有看法”"><a href="#重刑犯监狱长对他“早有看法”" class="headerlink" title="重刑犯监狱长对他“早有看法”"></a>重刑犯监狱长对他“早有看法”</h2><p>1969年，徐洪慈被安排在丽江507农机厂。这里实际上是一个关押重刑犯的监狱。监狱长叫李光荣，他对徐洪慈三次越狱的经历了如指掌，对这样的人，他早有看法。</p><p>在李光荣眼里，徐洪慈是个足智多谋的人，有自己的主意，动手能力很强，大家都叫他“智多星”，好像什么事都难不倒他。他视野开阔，知识面广，在犯人里享有很高的威信。</p><p>例如，犯人的鞋都很臭，怎么办？徐洪慈说：“很简单，拿白酒含一口往跑鞋、球鞋里一喷，臭味就没了。”还有，犯人的毛巾，都硬得像刷子，怎么变软？他也觉得很简单：“在水里烧一下，点几滴醋就好了。”这都是他以前学的生物化学等理科的一些知识，他不但会学，记忆好，还会联想，并且善于活学活用。也正因为有很高的威信，就有人为他通风报信。</p><p>在监狱里，犯人是无所不在的，有烧饭的，有在医务室的，还有理发的。这些人都有机会接近监狱首长，知道很多内幕。于是，一天，有人突然冒着风险告诉他——</p><p>“关于你的报告在起草中，说你在组织大家越狱，组织暴动。这可是李光荣对你下最后的毒手了，暴动的报告如果送上去的话，就是枪毙，看来这次是要置你于死地了。”</p><p>徐洪慈知道，他和李光荣之间的冲突已经不可调解，因为凡是打暴动报告的，没有活着的。这是监狱里最犯忌的。</p><p>当徐洪慈再次动起逃跑念头的时候，他想到了之前的两位管教——王金如和梁满杞，他曾对这两位管教发誓，要好好改造，再不逃跑。而此时此地，不走就将是等死。为了能活着走出监狱，徐洪慈开始了准备工作。</p><p>他对自己说：“我要证件，得保证在路上经得起任何盘查。必须要单位来说到哪里去，我因为什么事到什么地方去，然后盖个公章。这东西怎么弄呢？”</p><p>学生时代，徐洪慈已练就了一手非常漂亮的仿宋体，这时候派上了用场。他想，活字印刷字是活字，笔画为什么不能是活的呢？五六天刻个点，五六天刻个横，他居然成功了。</p><p>用这样的办法，他私刻了“云南省云县革命委员会”这几个最简单的字。而且他还把“介绍信”三个字都省了，给人感觉这就是云南省云县革命委员会的专用信笺。信笺上面有了抬头，下面就是要用的时候他写上：“兹由徐洪慈从某地到某地探亲，特此证明。”</p><p>抬头是要红色的，这样，他必须要搞到印泥。</p><p>一次，他终于找到了机会，趁没人看见的机会，用他那留得很长的指甲，深深地挑进去满满一指甲，然后把挖去的那一块抹平。这个印泥帮了他大忙。</p><p>下一步则是公章。他记得很清楚，监狱里放了几年的肥皂很干，不管什么牌子的肥皂，把头切平，很快就刻好一个图章。这个图章还用“云南省云县革命委员会”的字样，按好以后，把肥皂洗掉。三张介绍信就成了。</p><h2 id="就等停电那一夜，翻过电网就往南方跑"><a href="#就等停电那一夜，翻过电网就往南方跑" class="headerlink" title="就等停电那一夜，翻过电网就往南方跑"></a>就等停电那一夜，翻过电网就往南方跑</h2><p>徐洪慈不动声色地准备着。介绍信好了，还要攒粮票、备干粮、搭梯子。而507农机厂四面高墙，有电网，有机枪，有看守，有警犬。要逃离此处谈何容易。徐洪慈观察到一个契机：停电。他要等待一个停电的夜晚。</p><p>停电，看上去是无序的，没计划也没规律。但他发现，其实这也是有规律可循的。停电一般都是夏天用电量激增以后，问题在于，你不知道哪一天会停。于是，一进入7月，他就开始准备。他预感到8月份一定会停电。</p><p>8月7日的早上，宣布“断电”。原因是要把电拉给一个小化肥厂开工。</p><p>当一早宣布要拉电时，徐洪慈很亢奋，机会来了。</p><p>白天，他把该转移的东西都转移到了钳工间，从钳工间里面把可以拆卸的木梯零件，漫不经心地扔到那个早已看好的死角。出逃的时间，只可能选在两次点名之间，就是晚上9点点名逃出去，早上6点点名被发现。</p><p>当晚，他谁也不理，给大家感觉自己很不愉快，不想和任何人说话。这样，待会儿就没有犯人来跟他说话了。为了造成这样的假象，他晚饭不吃，闹着情绪睡觉去了，大家看他一天都睡在那里，如果万一晚上有人跟他搭话，他不理，人家也会以为他在闹情绪，就没人会搭理他。他要的就是你不理我的效果。</p><p>晚上点名的时候，他和大家一起去点名，点“徐洪慈”的时候，他很响亮地应答：“到！”大家都知道他在。点完名以后，所有人就按原来的秩序，洗脸的洗脸，睡觉的睡觉。他趁乱一下躲进了花坛，悄悄地从监房中转移了出来。</p><p>点名之前，他用衣服和很多杂物卷成一个人形，放在被子里面。别人一看，以为他还睡在那里。点名以后，他顺利完成了第一步，离开了监房，躲进了花坛。</p><p>待到夜深人静，他利用那个放到死角的、可以拆卸的梯子翻过了墙。过墙的时候发生了一个惊险，他突然发现梯子不够高，墙高三米五，梯子才两米，怎么办？墙角正好有两根扁担。徐洪慈觉得，一定是老天助他。他把两根扁担用短绳绑好，成功地翻越过去。</p><p>然后，他沿着这条路线，到钳工间，顺利拿到了他白天放在那里的网线袋，里面是他要吃的沙糕、要用的小刀、介绍信，还有他准备万一失败自杀用的那种用香烟屁股浸泡的药水等。然后，他从大柳树旁越过了电网，跳进了苹果园，撒开腿就往南方跑。</p><h2 id="逃亡路上：把昆虫煮熟，才不会苦"><a href="#逃亡路上：把昆虫煮熟，才不会苦" class="headerlink" title="逃亡路上：把昆虫煮熟，才不会苦"></a>逃亡路上：把昆虫煮熟，才不会苦</h2><p>徐洪慈一夜疾行三十公里。他打算南下东进，取道四川回上海。一场野外生存考验开始了。金沙江群山中，如果没有学过定方位，很容易困死山中。</p><p>徐洪慈不知道方向，也没有指南针，他把手表取下来，那时候还没有电子表，机械表都有分针、时针、秒针，只要用个小木棍，对着阳光插入土地，就会有阴影。只要把时针对着阴影，跟阴影保持同方向，那么在时针和12点之间就会有一条中分线，只要是在北半球，这条中分线在任何情况下都是南边。</p><p>只要当时有太阳，他就不会迷路。</p><p>他沿着金沙江走，不会有缺水的问题，但食物吃完怎么办？于是，但凡昆虫幼虫，不长毛的，颜色不鲜艳的幼虫都可以是食物。在这样的情况下，应该尽量寻找各种昆虫的幼虫，长毛的、鲜艳的一般都有毒，最好的就是天牛的幼虫，白白胖胖的，在树皮下挖出来，蚯蚓也是好东西，带壳的昆虫不能吃。徐洪慈说：</p><p>这些昆虫身上布满细菌，生吃不行，要解决这问题，只能烧水，生火，但野外生火会有烟，最容易被发现。但有办法避免生火产生的烟雾。你要先寻找一棵大树，树冠很密的那一类，比如香樟树、青冈树。在树底下，沿着树根，挖一个十字槽。十字槽的好处是会形成穿堂风，不用什么砖头垒灶，也不需要用树枝架篝火，有充分的氧气可以让树枝燃烧，而且操作也简单。选择树冠茂密的树，是让烟往上走的时候，碰到茂盛的树冠被过滤和疏散。这样在远处也看不到烟。</p><p>徐洪慈带着刀，他挖了一个十字槽然后点火，用热水瓶的铝盖子盛点水，放里面一烧，然后将一整把的昆虫幼虫放到里面煮，烧得它们团团转，蜷起来，沸腾，再蜷起来，凝固，熟透了。这样吃起来才不会苦。</p><p>正如徐洪慈的事先判断，监狱在第二天早上点名的时候，发现他不见了。507农机厂从来没发生过这种事，所有人都一阵唏嘘。李光荣更是恼羞成怒，一场地毯式的搜捕从丽江拉开。</p><p>徐洪慈没有想到，这么偏僻的地方会遇上民兵，这几个民兵当场就问他：</p><p>“哪儿来的？”</p><p>“我探亲。”</p><p>“探亲？从哪里到哪里？证明有吗？”</p><p>他就把证明拿出来，民兵一看，有点疑团，但是也找不出什么碴儿，就这样很侥幸地逃过了。</p><p>在过金沙江支流的时候，正是大雨后，河水暴涨。支流旁边有两个农民在种地，都劝他千万不要过去，水太急。8月份，咆哮的金沙江，谁也不敢过的。他知道这样很危险，但离开那个地方越快越好，越远越好，因为，后面随时可能有警犬追过来。</p><p>徐洪慈没有听从农民的劝告，结果，一下去，水就到了胸部。在走完三分之二的路时，他发现水更深了，越走阻力越大，马上就要没顶。这一刹那，他感觉自己“完了”。</p><p>人在最危险的一刹那会想起什么？</p><p>这一刻，还会有思维吗？经历过生死之间的徐洪慈多年后告诉胡展奋<cite>（记者）</cite>，这一刹那，他想起了他的女朋友，就是那个把他的话向上汇报，出卖了他，以致他被送进监牢的安娜<cite>（化名）</cite>。一直到最后，他也不明白，为什么自己临死都想着她。</p><p>很快，脚底触到了硬地，而且居然渐渐抬高了。他知道，快到河岸了，那个最低点过去了，他渡过了最低点，慢慢上去。</p><h2 id="面向南方，向多灾多难的祖国告别"><a href="#面向南方，向多灾多难的祖国告别" class="headerlink" title="面向南方，向多灾多难的祖国告别"></a>面向南方，向多灾多难的祖国告别</h2><p>金沙江水没有冲走徐洪慈，李光荣的脚步也没有追上他，十四天后，徐洪慈徒步走出云南。到达四川后，他立即买了火车票，又一次回到上海。</p><p>到上海后，他见了母亲，母亲给他一百块钱，并很自豪地说：“你是我的儿子，有骨气啊！”用上海话说就是：“模子，你是模子，侬是男人，侬还要逃啊，娘都服帖你了。”可以看出，他母亲也是支持他这个行动。他拿了这家里最后的一百块钱，走了……</p><p>与母亲再次见面后，徐洪慈消失在人海中。</p><p>十一年后，上海、云南两地给予徐洪慈平反通知书，而他们却找不到徐洪慈这个人。而此时此刻，远在蒙古国的后杭盖省，男孩安吉尔和波扬特兄弟俩，有一位美丽的蒙古妈妈和一位中国爸爸，这位中国爸爸的名字，就叫徐洪慈。</p><p>匆匆离开上海后，徐洪慈继续北上。一个月后，他来到了中蒙边境的二连浩特。</p><p>当徐洪慈向着边防站的灯光走近的时候，意外发生了——明明亮着的探照灯，忽然灭了。后来边防战士告诉他：</p><p>“这种现象，那是千分之一的概率啊，三年才可能碰到一次！就是因为突然断电，否则你过不了。”</p><p>事实上，当时徐洪慈根本没有考虑到雷达这个因素，他沿着岗楼的底线走过去，贴着岗楼走，那地方正是雷达的一个盲区。</p><p>按理说，探照灯没有以后，雷达还有备用的电源可以继续工作，但这个盲区恰恰是雷达扫不到的地方。误打误撞，徐洪慈过了边境线到了一个洼地。他不确定，但他的方位感告诉他，这个地方已经不是中国了。</p><p>从8月7日深夜到9月10日深夜偷越国境，这三十四昼夜是我一生中永远不会忘记的一段历险经历。每当我想起那些冒死逃亡的情景，始终万分激动。……在当时的条件之下，我只有走这条路才能保存自己的生命。我没有更多的漂亮话，我的行为的动机只是求得生存。我在地上蹲了几分钟，面向南方，向多灾多难的祖国告别。<cite>（《徐洪慈回忆录》未刊稿）</cite></p><h2 id="“你如何证明你是没有使命的？”"><a href="#“你如何证明你是没有使命的？”" class="headerlink" title="“你如何证明你是没有使命的？”"></a>“你如何证明你是没有使命的？”</h2><p>生存的道路走得这样艰难。徐洪慈在心里告别了祖国，走进了另一个国度。</p><p>1972年9月10日这个没有月光的黑夜里，徐洪慈走进了蒙古边防站。</p><p>他大着胆子推门一看，是蒙古人，这判断来于那人穿的制服。蒙古人也大吃一惊：半夜怎么突然来了一个蓬头垢面的不速之客？看样子不像蒙古人，跟他说话，语言也不通。</p><p>开始，徐洪慈担心他们会不会把自己送回中国。当时有很多人都被送回去了。凑巧的是，1972年的9月，蒙古刚刚颁布新的法律，其中内部法律规定：凡是越境的，未经审判，不能马上送回。</p><p>；再就是，一审时，徐洪慈的表达很到位，他越境到蒙古来没有物质上的诉求。这很重要。这让对方对他产生了同情。因为很多越境的人是盗窃犯、杀人犯，这些人他们当然是不会同情的，但有思想的知识分子就不一样了。这是他未被遣送回去的一个重要原因。</p><p>但还存在一个间谍问题，要取得对方信任，就得有凭证。“你刚才说的，你过来是没有使命的，是不是如你所说，请提供证据。”对方问道。</p><p>徐洪慈的记忆力很惊人，他说：“请你翻阅1957年8月2日的《人民日报》，上面有关于我的，对我批判的文章。我可以背一段给你听。”</p><p>他对批判自己的文章记忆尤其深，因为这是改变他命运的文章。法官当时就说：“如能找到报纸，我们的事情就好谈。”毫无疑问，他们找到了。这样，一种初步的信任找到了基础。</p><p>但是，徐洪慈的经历那么传奇，有些细节甚至是匪夷所思的。</p><p>“你说你能刻图章，你说你能写介绍信，你的字那么好？你给我试试看。”于是叫他当场动手刻一个。徐洪慈在新中国成立前是地下党，由于经常刻传单，仿宋体写得很好。法官没话说。</p><h2 id="你应该告诉我们你所知道的一切"><a href="#你应该告诉我们你所知道的一切" class="headerlink" title="你应该告诉我们你所知道的一切"></a>你应该告诉我们你所知道的一切</h2><p>然而，获得信任后的徐洪慈却提出了令蒙方恼火的要求。</p><p>徐洪慈越狱的时候，本来打算去苏联，但是发现钱不够，所以先到了蒙古。但他始终还想去苏联。原因很简单，他觉得在苏联机会更多。一、他会俄语；二、他可以找他的老师。当年医学院全是俄文老师，至少有五六个老师对他印象特别好。而且，苏联的经济情况也比蒙古好。</p><p>这样，他反复地要求，法官感觉自尊心受到了伤害，终于发了火：“我们是个主权国家，我提醒你注意，我们蒙古不是你到苏联的一条路。”“我们对你是很讲道义的，是吧？你怎么开口闭口还是到苏联？”</p><p>徐洪慈吃软不吃硬的人，他向巴依玛法官表示：“我愿意留在蒙古。”</p><p>蒙古法院很快对徐洪慈的蒙古法院很快对徐洪慈的越境进行了审判。此间，法官巴依玛与徐洪慈有了进一步的交流，他向徐洪慈提出了新的要求：</p><p>“我们救了你，你应该告诉我们一些我们感兴趣的事情。比如说，中国现在的经济情况。你曾经长期在党内工作，曾经在华东局工作，按你所说，一直和华东局的高层领导有接触。你应该告诉我们你所知道的一切。还有，听说监狱里大量饿死人。你在监狱待了这么长时间，而且，三年自然灾害，你也在监狱里，你应该告诉我们监狱里的真实情况。”</p><p>他认为徐洪慈掌握很多党内情况，而徐洪慈确实也了解很多情况。</p><p>但徐洪慈听了以后，很感慨：“尽管自己是个逃犯，尽管受到了不公正待遇，但内外是要有别的。”</p><p>从当时的立场，他觉得，中国出现了很多负面的甚至黑暗的现象，这是暂时的。如果以此博求自己的待遇，以此博取自己的好处的话，自己就是卑鄙的。他对巴依玛法官说：“好比我们两家是邻居，我们家出了事情，我投奔你这家邻居。你却说，我是可以帮助你的，不过，必须把你父母的隐私告诉我。你说这样的邻居有道义吗？”</p><p>巴依玛一听，觉得很难为情。他说：“是的，是的，是的。那就到此为止吧。”</p><h2 id="“蒙古的监狱把我野化了”"><a href="#“蒙古的监狱把我野化了”" class="headerlink" title="“蒙古的监狱把我野化了”"></a>“蒙古的监狱把我野化了”</h2><p>在蒙苏边境的宗哈拉，人人都知道一个汉人的故事——苏武牧羊。两千多年前，苏武就曾在宗哈拉不远的贝加尔湖放牧。</p><p>如今，宗哈拉又来了位中国人——徐洪慈。他要为自己的非法越境，在宗哈拉的大森林里服刑一年。</p><p>蒙古监狱给了徐洪慈另一种体验。他说：“中国的监狱把我驯化了，蒙古的监狱把我野化了。”据徐洪慈介绍，蒙古所有被流放的人都集中在宗哈拉。宗哈拉自然条件非常严酷，那是个大森林，在冬天，天天是零下四十摄氏度，西伯利亚大寒潮可以直接到达那里，横扫天地之间；夏天则是另一种严酷，这里的三种昆虫会轮番而上。宗哈拉的蚊子，没有那种嗡嗡嗡的声音，天一黑，这种大蚊子一口咬住你，像抽水泵一样拼命地吸，当地人叫它“血泵”。</p><p>到了早晨，天一亮，太阳一出来，牛虻就来了，它会把你当牛一样叮，牛和马的皮那么厚，牛虻照样能叮，所以所有的犯人最怕牛虻，叮下去就是一个大包。除此以外，午睡的时候，还有一种小黑虫会钻进蚊帐。这样，在宗哈拉的夏天，一天二十四小时不断受折磨，这些昆虫三班倒地折磨着这里的犯人。</p><p>然而，在徐洪慈看来，在宗哈拉的大森林中，繁重的体力劳动、丧失了母语的环境尽管严酷，但那是单纯的身体的劳作和生活上的艰辛，没有像李光荣那样不停地进行精神和肉体折磨的狱警，他甚至感受到了一些快乐。。</p><p>宗哈拉的犯人，从犯罪类别来说偷盗的多，基本没有政治犯，没有反革命犯。在这样一个环境下，徐洪慈没有学会喝酒，却学会了打人。在那里，人和人关系很简单粗犷。一语不和，打人是常见的。</p><p>有两次打架给他留下深刻印象。</p><p>第一次是和管教打架，管教叫巧灵。徐洪慈身高一米八，但是在蒙古大汉眼里，他是小个子。巧灵把他举起来，扔到地上，一拳就把徐洪慈右边两根肋骨打断了。徐洪慈说蒙古人的拳头簸斗一样大，像我们武侠小说里描写的那样。</p><p>蒙古人很豪爽，朋友们和巧灵说：“你打得太过了，你把他肋骨打断了，他发高烧了。”一听这话，巧灵觉得很对不起徐洪慈。他丝毫没有自以为是一个管教，就端着架子。第二天就向徐洪慈道歉，拿了一袋马肉去看他，当时那里盛行吃马肉。“对不起！不过你是中国人的这个，好汉、硬汉！好，很佩服！”这是第一次打架。</p><p>第二次打架，是徐洪慈在监狱厨房里工作的时候。牢头经常到这里多吃多占，徐洪慈不允许，就打了起来。徐洪慈拿一个冒着青烟的熨斗就上去了。对方人高马大，比巧灵还厉害，像个黑猩猩一样。徐洪慈居然拿着个熨斗烫上去，烫了个烙印。蒙古大汉打不过他就逃走了，也没有回头报复他。</p><p>徐洪慈觉得这个地方是粗犷的，道理也很简单，人和人之间有种最单纯简单的东西。和蒙古人相处，他一直有愉快的回忆。</p><h2 id="越狱、越境、叛国投敌，我简直是十恶不赦"><a href="#越狱、越境、叛国投敌，我简直是十恶不赦" class="headerlink" title="越狱、越境、叛国投敌，我简直是十恶不赦"></a>越狱、越境、叛国投敌，我简直是十恶不赦</h2><p>一年刑满后，徐洪慈已经能熟练地使用蒙古语。他不能想象，在异国他乡，一段爱情正向他走来。1974年，徐洪慈在首都乌兰巴托的医院遇见了一位叫奥永的姑娘。</p><p>奥永回忆：“我和徐洪慈是在乌兰巴托的一家医院认识的。那时候我是一名护士。有一天，徐洪慈来我们医院看眼睛，我们就这样认识了。”</p><p>当时，徐洪慈四十多岁，奥永二十一岁。年龄几乎相差了一代人，然而，奥永说：“你知道我为什么那么可怜他吗？他虽从监狱里出来，但他是有思想有头脑的人，是个好人。我心里清楚他到底是好人还是坏人。”</p><p>就这样简单，他们从相识，走到结合。</p><p>奥永总是记得徐洪慈说的话，他说：“奥永啊，我知道你是个孤儿，你不要怕我。我们可以在一起生活，你跟我去后杭盖，我们在那里生活。”</p><p>在蒙古腹地的后杭盖省，徐洪慈终于有了自己的家。徐洪慈给别人做事，干体力活，搬木头、石头。当时蒙古还没有什么机器，使用的是那种两个把儿的小推车，就这样，徐洪慈给人家做了八年的活儿。他一边干活，一边还做饭做家务。“三十多年，都是徐洪慈做饭。我从没做过饭。……那时候我们蒙古的妇女们说：什么活都是徐医生做，你就不能做做饭什么的吗？你多有福气啊！我跟徐洪慈说：要么我来做饭。他说：不用，不用，你就待在家里，把两个孩子看好就行。别的所有的事情都由我来做。”</p><p>徐洪慈在自己的家里心甘情愿地为妻儿们操持着整个家。然而，在他的心底，自己真的要在异国他乡终老此生吗？</p><p>从逃出牢狱后，徐洪慈一直没有和家里人联系，他觉得自己还在危险中，如果和家里联系的话，自己的情况势必被政府掌握，这样他就有可能被引渡。他后来回忆说：</p><p>……这里与世隔绝，失去祖国，失去母语环境，我还能做什么？我的一切特长都不被认可，一切研究也就无从谈起，……四次越狱后，我已经耗尽了自己的一切力量坚持到底。现在我已四十一岁，人生的一大半已经过去，年轻时的理想和抱负全部破灭了。<cite>（《徐洪慈回忆录》未刊稿）</cite></p><p>他仍然非常关心祖国，也很想知道国内的情况。在蒙古出狱以后，第一次拿了工资，他就动脑筋买半导体收音机来收听广播。总算买来一个，只要有空，他就不断地听国内的情况。国内形势的变化，他都是由此了解的，比如1972年至1976年的国内社会事件，比如“文革”的结束。</p><p>大概在1979年，通过收音机，他揣摩各种社论文章，闻到了一种别样的气息：种种迹象表明，中国将发生巨大的变化。但这个变化，却是他不敢想象的。他认为自己一辈子够“反动”的了：在反右时他“反动”的言论不说，在“文革”时候的作为不说，就单说越狱，在当时就是个死罪啊。而他不仅越狱，还越境，这是叛国投敌，还有比这更严重的吗？</p><p>他想：“我这样的人简直十恶不赦，不可能会得到宽恕的。”</p><p>但很快，他逐渐意识到发生了重大变化。他渐渐闻风，右派都可能改正——这让他觉得有了希望，他觉得自己所有的前提就是右派问题。</p><p>他盼望的，也终于在1981年的年终成真。</p><h2 id="平反像跷跷板一样翘着"><a href="#平反像跷跷板一样翘着" class="headerlink" title="平反像跷跷板一样翘着"></a>平反像跷跷板一样翘着</h2><p>1981年冬天，我收到母亲的信，她告诉我上海第一医学院党委为我的右派问题平反，并附上了手抄的改正书。</p><p>1982年春天，母亲又通知我，上海市公安局已对我的劳动教养问题平反。这又进了一步。但是久久期待的云南省丽江中级法院的平反书却迟迟不来。我相信这个问题阻力最大，很可能无法解决。<cite>（《徐洪慈回忆录》未刊稿）</cite></p><p>云南那边，像跷跷板一样翘着。云南不同意。</p><p>这时候，他做了一个决策，决心克服恐惧心，试试给有关中央领导写信。他在华东局工作过，曾经有两个老领导，一个叫黄辛白，1981年已经担任国家教育部的副部长，还有一个就是乔石同志，已是党和国家领导人了。早在50年代徐洪慈读大学以后，和这两位领导联系已经很少了，后来自己出了事就更无法联系。于是，他大着胆子写信，把自己的遭遇告诉这两位老领导。</p><p>两位老领导都得到了他的来信，而且两位都有反馈。信中说：“这样的事情是不是属实，要查。也并不因为你是我的老部下，就偏信你的一面之词。第二，查出来如实，你就平反，你就是个大学生。”</p><p>两位领导无论口头还是书面都有过指示：“这事情要办！”但是，事情依然一波三折。</p><p>全国都在为右派平反，凭什么不给他平反？领导都发了话，但事情没那么容易，下面一直反弹，特别是云南省法院、丽江地区法院，他们说：“他错划右派不是我们的事情，是上海方面的事情，在我们这里，他犯下了不容原谅的错误，不能赦免的错误，就是越狱。”</p><p>对于丽江507重刑监狱监狱长李光荣来说，徐洪慈这个人是他所在监狱唯一越狱成功的人，他居然能从重刑犯监狱逃出去。现在得知他后来逃到蒙古去了，在李光荣看来，情况更加严重。叛国投敌、越狱，两罪并罚，不能平反。这是罪不可赦的。</p><p>李光荣曾经捏造徐洪慈组织犯人集体越狱的材料，企图置徐洪慈于死地，徐洪慈是在接到别人的报信后才决定逃亡的。因此，1972年的越狱，对徐洪慈来说可谓是一场生死逃亡。</p><p>我于是继续向中央有关部门写信，要求丽江地委为我彻底平反。冤案在前，死亡逼迫在后。如果我不越狱、不自救，那么今天的平反书恐怕只能对着徐洪慈的墓碑朗读！<cite>（《徐洪慈回忆录》未刊稿）</cite></p><p>徐洪慈继续写信，直到后来，中央领导有了明确的表态：</p><p>徐洪慈这个事情，首先判断的就是前提何在。他是越狱的，他是越境的，但是谈任何事情要有前提，如果他不被错划成右派，他怎么会发生后面那么多事情呢？后来怎么发生的？因果，一切都有因果。所以一切的根源，都是因为这是一个冤枉的事。既然冤狱被平反了，前提被推翻了，那么后面一切都不能成立。</p><p>这最后一句话为他定了性。</p><p>此后，为徐洪慈平反的指示，是直接从中央发指示到云南省高级人民法院，自上而下的。这是来自中央的力量，也是来自道义的力量。</p><p>这是一种迟来的公正，虽然迟来，但还是公正的。1982年6月，徐洪慈得到了彻底的平反。</p><h2 id="难道是老天给我的征兆吗？"><a href="#难道是老天给我的征兆吗？" class="headerlink" title="难道是老天给我的征兆吗？"></a>难道是老天给我的征兆吗？</h2><p>1982年6月19日的上午真的下了一场鹅毛大雪，千山万壑，白雪皑皑，“六月飞雪，天象示冤”，蒙古人奔走相诉，连称千古奇闻。我踟蹰在大街，如痴如呆——难道是老天给我的征兆吗？关汉卿的《窦娥冤》是奇冤，我的案情难道不是奇冤？四次越狱，万里亡命，沉沦异国，娶妻生子，也是闻所未闻啊！<cite>（《徐洪慈回忆录》未刊稿）</cite></p><p>对徐洪慈来说，真正的冤狱平反了。六月飞雪，对他个人来说是一个彻底的拐点。这意味着，他可以回中国了。</p><p>1982年10月，中国驻蒙古大使馆致信徐洪慈：按照有关规定，你已获彻底平反，“我们恢复你的中国国籍，你要到乌兰巴托中国大使馆来领你的护照，领了护照以后，你回国探亲也可以，回国定居也可以”。接到信的徐洪慈欣喜若狂。</p><p>那是永生难忘的一刻。</p><p>然而，蒙古人也找他谈话。</p><p>这次露面的是蒙古国家安全局，大意是：“徐洪慈，我们对你不错吧。”</p><p>他说：“你们是我的恩人，在我面临死亡的边缘，你们救了我。”</p><p>“既然这样，”蒙古安全局的人说，“那么，现在你的祖国为你平反了，要你回去，你怎么看？”</p><p>“我很矛盾，我在这里成家，当然我永远忘不了我的祖国。”</p><p>“我建议你要慎重考虑这件事情，我们欢迎你加入蒙古籍。”</p><p>到这个时候，徐洪慈觉得非常奇怪：你们一直不让我加入蒙古籍，现在为何同意了？他曾经提出过这个想法，那是为了安全，假如加入了蒙古籍，他们就不能引渡他了。引渡的阴影一直笼罩着他，他怕被抓回去，他怕再见到李光荣。但是，当时蒙古对他的要求不置可否，一直拖着。现在却说，“欢迎你加入蒙古籍……”</p><p>徐洪慈说：“我就直说了，我曾经多次流露过这个意思，你们不理我。现在我的祖国要我回去了，你又要我加入蒙古籍了，就是不想让我回去嘛。”</p><p>那个蒙古人说了一句很妙的话：“这是常理嘛，女人的魅力就在于她没有离婚。”</p><p>这句话说得很奥妙，简直不像蒙古人说的。</p><p>徐洪慈的回答则是：“祖国的魅力就在于永远令人难忘。”</p><p>二十五年，沉冤终于洗清。有多少次梦里，被李光荣追赶、折磨，又有多少次在梦里，母亲远远地招手。徐洪慈想家，什么力量都阻止不了他回家的脚步。</p><h2 id="流亡十一年，“是政治环境害人，不是她害人”"><a href="#流亡十一年，“是政治环境害人，不是她害人”" class="headerlink" title="流亡十一年，“是政治环境害人，不是她害人”"></a>流亡十一年，“是政治环境害人，不是她害人”</h2><p>流亡十一年，徐洪慈终于踏上了回家的路。</p><p>昨晚我还是“逃犯”，今天已是“华侨”，翻来覆去怎么也睡不着：“剑外忽传收蓟北，初闻涕泪满衣裳。却看妻子愁何在，漫卷诗书喜欲狂。白日放歌须纵酒，青春作（做）伴好还乡。……”可是我还有青春吗？我的心一阵阵绞痛着。<cite>（《徐洪慈回忆录》未刊稿）</cite></p><p>上海石库门的房子，邻里之间，鸡犬相闻。听说徐洪慈要回来，全弄堂都出来迎接他。</p><p>徐洪慈终于见到了他的母亲：“上次逃回来的时候是1972年，再次回来是1983年，整整十一年了。”母子相拥痛哭。</p><p>母亲抱着他说：“你真是我的儿子。”就像当年他逃的时候说的：“你真真是我的儿子。”</p><p>这是1983年，徐洪慈从蒙古第一次回到上海。弄堂里所有的老人都流下眼泪，这是发生在他们身边真实的故事。常言道，父母在，不远游，而今游子不复青春，却终于回到娘身边。</p><p>从1958年至今二十五年，我第一次在家和母亲共进晚餐，真有说不完的话。我也拿出奥永和孩子们的照片。母亲一直和我谈到深夜。<cite>（《徐洪慈回忆录》未刊稿）</cite></p><p>如果说，在徐洪慈亡命天涯的十一年中，母亲是他始终的牵挂，那曾经留下爱恨的医学院、那梦中挥之不去的云南重刑监狱，他该如何了却这些心事？</p><p>学校位置没变，现在还在医学院路，枫林路中山医院旁边。</p><p>徐洪慈回到学校，第一感觉就是，学校建筑比以前多了，路比以前窄了；第二感觉就是伤感。很多同学都留校了，而同学们看到他，居然一眼就认出了他。他很有特征：第一，个子高，一米八；第二，两道浓眉；第三，太多的人大吃一惊：“你还活着？！”</p><p>传说有很多版本，有的说他早就死在困难时期的白茅岭监狱，还有说他死在云南，死在云南的深山野林中。但没有关于他一个人逃到蒙古的传说，因为这已经超出了人们的想象。医学院轰动了。</p><p>大家马上决定要开一个欢迎会。在欢迎会上，他泣不成声。当年的同学朱世能，后来成为我国医学界的著名专家，他说：“当时你的成绩比我都好，没想到你吃了那么多苦，相比之下，我们都还算是顺利的。我们经常埋怨命运对我们不公，但命运对你是最不公的。”</p><p>说到徐洪慈，大家都绕不开一个人，那就是安娜。</p><p>那个曾经和徐洪慈爱得轰轰烈烈，又揭批他最彻底的安娜在哪里？热心的同学要立即安排他们见面。这样一个爱恨交织的人，徐洪慈见还是不见？</p><p>事实上，徐洪慈无论是在白茅岭的监狱，还是在云南的监狱；无论是越狱的时候，还是渡过金沙江的时候；无论是差点被急流吞没，还是到蒙古的宗哈拉大森林，他永远忘不了的就是安娜。</p><p>他想，最好不见她，不见最好。</p><p>但他抵挡不了一种力量，人心的力量，人性的力量。最终，他就跟着姓沈的同学去了。</p><p>姓沈的同学把他安排在一个房间，让他等着。这一刻，他心潮汹涌，所有的往事涌上心头。门一开，安娜进来了。在场的一个是姓沈的同学，还有一个叫小熊的年轻医生。</p><p>事后他们回忆说，这个场合他们永远忘不了。那种面部表情，那种尴尬，那种肌肉的抽搐，那种眉眼，无法表述。两个人都非常尴尬，可见双方在对方情感世界所占的地位，这是无法隐藏的，这一切都会自动出来说话，人的情感自动打开。</p><p>小熊和沈医生借口走了。他们说：“这个场合我们也看不下去，我们也不合适看下去。”</p><p>徐洪慈后来回忆说，两人坐下，长久无语。然后还是他先开口说话，却是他事后回忆起来，都觉得自己很愚蠢的问话，就是：“你还好吗？”</p><p>安娜也问他：“你还好吗？你父母还好吗？”</p><p>这种时候，两个人的大脑都已经停顿。</p><p>两人相见之后，安娜留下了三句话。</p><p>她对沈医生说：“没想到他的妻子比他小二十多岁，做他女儿还嫌小。”这是第一句话。这是女人的本性，听上去有点酸溜溜的。</p><p>第二句话：“他当时那个处境不能怪我，我也是走投无路。”</p><p>第三句话：“我们现在都要感谢邓小平，不管是他还是我，我们永远不要忘记邓小平的恩德。”</p><p>这三句话给徐洪慈印象很深，记者曾经问他：“你认可不认可？”</p><p>他说：“严格地说，前面两句话总要打点折扣。”“我现在看来，不是安娜害人，是政治环境害人，所以这场纠结就这么结束了。”</p><h2 id="他怎么就这么走了呢？"><a href="#他怎么就这么走了呢？" class="headerlink" title="他怎么就这么走了呢？"></a>他怎么就这么走了呢？</h2><p>悲喜交集、恩怨了结之后，徐洪慈立即回到蒙古。这时，他的小女儿叶塞尼亚刚刚出生。</p><p>1984年，徐洪慈带着妻子奥永，儿子安吉尔、波扬特和刚满月的女儿叶塞尼亚一起回到了上海。此后，徐洪慈成了上海石化总厂教育中心的高级讲师，奥永还做了老本行——护士。他们的生活终于恢复了正常。</p><p>奥永说：“徐洪慈曾经跟我说过，他要回去。他说：‘我不想住在这里，这不是我的家乡。’我说：‘你要去哪里？你的家乡就在这里。’他说：‘我要走。’来上海三十几年他经常这么说。”</p><p>对于徐洪慈来说，似乎所有的恩怨都了结了，组织上也恢复了他的党籍。2008年4月14日，徐洪慈所在的单位给他颁发了老干部离休证书，从颁发日这一天起，徐洪慈由退休改为离休。</p><p>然而，拿到这张离休证书后的第三天，徐洪慈就因癌症引发的呼吸衰竭去世。三个月后，组织上下发了《关于徐洪慈同志享受局级待遇的批复》。悲痛，留给了他的妻子和孩子。</p><p>“跟徐洪慈在一起三十多年，他从没辜负过我，我们从没说过什么过激的话。徐洪慈为什么就这么丢下我和孩子们走了？三个孩子都大了，他怎么就这样走了呢？”</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>徐洪慈去世以后，记者胡展奋向我们转述了徐洪慈传奇的一生。从1999年开始接触他的胡展奋，回顾他们这些年的交往时说：“我当时没准备写他，当时听人家谈这个故事，觉得他的遭遇很离奇。而第一次和他接触之后，却印象深刻，那就是——这个人不轻易相信人，有戒备心，为人有点冷淡，但内心很深，见多识广，阅历非常丰富。”</p><p>他身上的那种冷淡是，不惊讶。你和他谈话，你说了可笑的话，他是这样；你说了很离奇的事情，他也这样。</p><p>他表情不轻露，波澜不惊的那种。这波澜不惊的表情，不是人为的、刻意的、克制的。这并非休养好。你能打动他的事情很少，他自身经历过那么多，惊涛骇浪在他面前是没有传奇的。他就是这么个人。</p><p>有一次，胡展奋问徐洪慈：“你的大半生都是在苦难当中挣扎的，你怎么看待自己的人生呢？”</p><p>徐洪慈是这么总结自己的：</p><p><strong>我在自己的专业上，在自己原先的人生抱负上，我一无所成。像我这样的人，应该对那种残酷环境、恶劣环境的反抗，这种个人的成功，人格上的成功，我这一生，只有这一点。我心足了。这一点，我对得起自己。</strong></p><p><strong>按世俗的标准，徐洪慈没有贡献出什么发明创造，没有贡献多少物质财富，他不是一个成功人士。但对他自己而言，保持了自己人格的完整，昭示了精神不屈不挠的倔强，维护了一个平凡生命的尊严，他的生命，在另外一个维度上企及了一种神圣庄严的意义。</strong></p><blockquote><p>讲述人：奥永、胡展奋；编导：谭悦；文稿统筹：张丹翔，荣挺进</p></blockquote>]]></content>
      
      <categories>
          
          <category> 精选文摘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 徐洪慈 </tag>
            
            <tag> 网易人间 </tag>
            
            <tag> 传记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>喜剧人生</title>
      <link href="/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/%E5%96%9C%E5%89%A7%E4%BA%BA%E7%94%9F.html"/>
      <url>/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/%E5%96%9C%E5%89%A7%E4%BA%BA%E7%94%9F.html</url>
      <content type="html"><![CDATA[<img src="/个人随笔/喜剧人生/大鱼求婚剧照.jpg" title="男主角向妻子求婚剧照"><p><cite>——关于电影《大鱼》</cite></p><blockquote><p>本文是之前应邀写在公司公众号上面的一篇文章，后来想想，觉得这部电影实在喜欢。便又把文章翻了出来，去掉开头放在了自己的博客上。</p></blockquote><p>前几日同事小聚，席间老朱提到了一部影片-《大鱼》，对它评价甚好。当时自己也感慨，没想到现实中的朋友里也会遇到看过且喜欢这部算不上大众的电影。想想自己当年看这部电影时的情形，似乎又体味了一把当年的感动。所以，恰巧本期能让我来信马由缰地“乱”写一气，我便来向各位看官分享分享这部片子吧。</p><p>电影以孩子的口吻来叙述其爸爸传奇的一生。爱德华·布鲁姆是个喜欢吹牛的老头，总喜欢炫耀年轻时旅行推销的经历，儿子并不相信，觉得父亲很虚荣浮夸，父子关系渐渐疏离。直到父亲不久于人世，儿子决定回去见父亲最后一面，最后终于领悟到父亲充满激情和想象的一生。</p><p>影片在前一小时三十分钟内，它可以拿来当成一个魔幻版的《阿甘正传》来看，绝不会让人觉得乏味，只会因为那些五彩缤纷的幻想而被深深吸引。而在最后十分钟，在讲故事最关键的时候，如同烟花散尽、笙箫停歇，满天星斗在夜空中显露出来，纤尘不染。你只觉得那一瞬间，你明白了所有的星光，而你却不能言语。</p><p>长久以来我也会时不时去想，到底我们生活的意义在于哪里，抑或是，作为承担了许多责任的男人，我们打拼的归宿在于何处？尤其是年龄愈发增长，承担也相应加码。看客可能也会跟鄙人有过同样的感想。限于篇幅的缘由，不在这里不自量力地去探讨这么深的难题了。</p><p>让我们先来回顾片中男主角<cite>（伊万·麦克格雷格饰）</cite>的故事。据男主角的叙述，自己年轻时是一位意气风发，野心勃勃的人，他一直想离开自己居住的小村庄，去体验一下外面大城市的生活。在旅行途中，他曾遇到过一个老巫婆，一个巨人，一个叫做“幽灵城”的地方，一个晚上会变成狼人的马戏团老板，还包括一名有着两个不同性格但只有一个身体的中国歌手和一条谁也抓不住的“大鱼”。<br>在这些传奇之余，爱德华也道出了自己和妻子桑德拉的爱情故事——他如何遇到她，如何被她的美丽打动并向她求婚。</p><p>这看似精彩传奇而又充满奇幻的经历在结尾的时候被导演“揭了老底”，在葬礼上，一个个父亲故事中的原型人物陆续出现在儿子的视野中，“巨人”没有故事中的那么高大，“双胞胎姐妹”也不是连体的……观众也会跟片中儿子一样，明白父亲的人生经历其实跟我们大家没有区别，都是平凡质朴的一生。多年来父亲一直用一个个精彩的故事把他的经历“包装”给身边的人分享。平淡无奇的生活经历因为他的热情乐观变得精彩温暖。</p><p>尤其当年男主爱上他后来的妻子时，这个窘迫的“乡巴佬”没有思前想后左右顾虑，没有考虑敌我差距。后来竟然用自己的率真执着赢得了女主的芳心。直到后来，多年后作为母亲的她回忆当年清早醒来，看到窗下满眼的鲜花以及男主站在中间温暖真诚的微笑的种种情形。嘴角竟还会扬起幸福的微笑，尤为末了，在儿子面前隐隐地泛起了泪光。</p><p>勤奋、勇敢、好奇、真诚、善良、守信、忠诚、坚持、仁慈……你们看，电影用尽篇幅，不过是要向我们诠释一个这样的男人的世界。尽管它是用一个个夸张的故事包装过的。在这世界上，只有在你所爱的人之外，才需要辨别所谓真假。生活中的事，有种种说法。所谓真相，可能是最令人乏味最让人难以接受的。而在生活外表涂上彩虹颜色的人，他们值得尊重和信赖，因为他们的爱。</p><p>这爱，我觉得不仅仅是对于周围人的爱，更是对于生活的热爱。</p><p>正因如此，我也坚持认为此片是一部十足的喜剧，尽管它让人动容，让人感动流泪。</p><p>看完片中男主“传奇”的人生，想来我们生活的意义，大概就也在于我们对生活的无限热爱以及对这爱所能及的人、事、物的追求过程了吧。</p><p>最后，谢谢各位看客，献上片中的一段精彩台词：</p><p><strong>有些笑话你是否因为听过太多次而忘了它为何好笑了？</strong></p><p><strong>后来你又听到它，突然间它就像全新的笑话。</strong></p><p><strong>你想起为何一开始会喜欢它了。</strong></p><p>王亚雷</p><p>2016.5.1</p><blockquote><p>部分文字摘自豆瓣影评以及电影相关的百科。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大鱼 </tag>
            
            <tag> 人生 </tag>
            
            <tag> 影评 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
