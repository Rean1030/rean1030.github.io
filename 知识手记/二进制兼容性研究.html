<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="yalei.wang"><title>二进制兼容性研究 | 往 事</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">二进制兼容性研究</h1><a id="logo" href="/.">往 事</a><p class="description">尽人事 知天命</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">二进制兼容性研究</h1><div class="post-meta">May 20, 2018<span> | </span><span class="category"><a href="/categories/知识手记/">知识手记</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><blockquote>
<p>软件中不同模块动态链接库的调用是常见现象。假设有模块A调用到了模块B，而B的代码进行了改动，这个时候B编译出来的dll文件，在A不进行重编的情况下，还能够直接被A调用而不出现异常吗？</p>
</blockquote>
<h2 id="一、几种兼容类型"><a href="#一、几种兼容类型" class="headerlink" title="一、几种兼容类型"></a>一、几种兼容类型</h2><ul>
<li><p>二进制兼容（Binary compatibility）</p>
<p>  程序针对其依赖模块的正确加载和运行</p>
</li>
<li><p>源代码兼容（Source compatibility）</p>
<p>  源码所依赖的模块在编译时不发生改变</p>
</li>
<li><p>行为兼容（behaviourcompatible）和Bug兼容（bugcompatible）</p>
<ul>
<li>程序表现与其他模块相同</li>
<li>上面情况包含Bug表现的扩展</li>
</ul>
</li>
</ul>
<p>后两种兼容情况这里先不讨论，那么二进制兼容与源代码兼容具体来说是怎么回事呢，二者之间又有什么关系呢？</p>
<p>接着开头说，如果上面提到的B模块改动并编译之后，依赖它的A能继续正常调用B里面的东西，并且正常运行，那么我们说这种兼容情况是二进制兼容；如果A需要重新编一下才能保持正常调用运转，则称这种情况为源代码兼容。</p>
<p>实际工作中开发一般很难察觉到这种细微的差异，因为底层模块被改了以后，在IDE启动运行的时候会检测到B重新生成了dll，这个时候A也会跟着重编去继承新dll的二进制接口。这也导致如果出现二进制兼容问题的时候，我们开发在IDE直接调试自测很难发觉其中的微妙差异。</p>
<p>但当程序部署之后新旧版本之间安装替换，一些公共模块对于上层依赖模块的二进制兼容问题便暴露出来了。比如我们计价程序Bin文件夹中的dll，每个地区版本均会带上，当后出的地区版本安装时路径下已经有了较老的其他地区版本，Bin文件夹中的dll便会被替换。这个时候就出现了老的上层模块在没有重编的情况下调用较新依赖模块的情况，也就是上面说到的二进制依赖所出现的场景。</p>
<h2 id="二、如何保证二进制兼容"><a href="#二、如何保证二进制兼容" class="headerlink" title="二、如何保证二进制兼容"></a>二、如何保证二进制兼容</h2><p>那么在修改代码的时候怎么能保障二进制的安全呢？</p>
<h3 id="1-允许的修改方法"><a href="#1-允许的修改方法" class="headerlink" title="1.允许的修改方法"></a>1.允许的修改方法</h3><pre><code>* 增加非虚函数，增加signal/slots，构造函数什么的。
* 增加枚举enum或增加枚举中的项目。
* 重新实现在父类里定义过的虚函数 (就是从这个类往上数的第一个非虚基类），理论上讲，程序还是找那个基类要这个虚函数的实现，而不是找你新写的函数要，所以是安全的。但是这可不怎么保准儿，尽量少用。
      o 有一个例外: C++有时候允许重写的虚函数改变返回类型，在这种情况下无法保证二进制兼容。
* 修改内联函数，或者把内联函数改成非内联的。这也很危险，尽量少用。
* 去掉一个私有非虚函数。如果在任何内联函数里用到了它，你就不能这么干了。
* 去掉私有的静态成员。同样，如果内联函数引用了它，你也不能这么干。
* 增加私有成员。
* 修改函数参数的缺省值。
* 增加新类。
* 对外开放一个新类。
* 增减类的友元声明。
* 修改保留成员的类型。
* 把原来的成员位宽扩大缩小，但扩展后不得越过边界（char和bool不能过8位界，short不能过16位界，int不过32位界，以此类推）这个也接近闹残：原来没用到的那么几个位我扩来扩去当然没问题，可是这样实在是不让人放心。
</code></pre><h3 id="2-禁止的修改方法"><a href="#2-禁止的修改方法" class="headerlink" title="2.禁止的修改方法"></a>2.禁止的修改方法</h3><pre><code>* 对于已经存在的类：
      o 本来对外开放了，现在想收回来不开放
      o 改变父类 (增加父类，减少父类，重新给父排序).
* 对于类模板来说：
      o 修改任何模板参数（增减或改变顺序）
* 对于函数来说：
      o 不再对外开放
      o 彻底删掉
      o 改成内联的(把代码从类定义外头移到头文件的类定义里头也算改内联)。
      o 改变函数特征串：
            + 修改参数，包括增减参数或函数甚至是成员函数的const/volatile描述符。如果一定要这么干，增加一个新函数吧。
            + 把private改成protected或者public。如果一定要这么干，增加一个新函数吧。
            + 对于非成员函数，如果用extern &quot;C&quot;声明了，可以很小心地增减函数参数而不破坏二进制兼容。
* 对于虚成员函数来说：
      o 给没虚函数或者虚基类的类增加虚函数
      o 修改有别的类继承的基类
      o 修改虚函数的前后顺序
      o 如果一个函数不是在往上数头一个非虚基类中声明的，覆盖它会造成二进制不兼容。
      o 如果虚函数被覆盖时改变了返回类型，不要修改它。
* 对于非私有静态函数和非静态的非成员函数：
      o 改成不开放的或者删除
      o 修改类型或者const/violate
* 对于非静态成员函数:
      o 增加新成员
      o 给非静态成员重新排序或者删除
      o 修改成员的类型, 有个例外就是修改符号：signed/unsigned改来改去，不影响字节长度。
</code></pre><h3 id="3-错误方法的分析"><a href="#3-错误方法的分析" class="headerlink" title="3.错误方法的分析"></a>3.错误方法的分析</h3><h4 id="取消导出或移除一个类"><a href="#取消导出或移除一个类" class="headerlink" title="取消导出或移除一个类"></a>取消导出或移除一个类</h4><p>改前 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KDECORE_EXPORT</span> <span class="title">KUrl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KUrl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因: 上面类的符号没有加入到生成的库的导出符号列表中，因此其他库或应用不能看见它们。</p>
<h4 id="改变类的继承层级"><a href="#改变类的继承层级" class="headerlink" title="改变类的继承层级"></a>改变类的继承层级</h4><p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass1, <span class="keyword">public</span> BaseClass2</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass, <span class="keyword">public</span> OtherBaseClass</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass2, <span class="keyword">public</span> BaseClass1</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因：类中成员变量的大小或（和）顺序改变了，引起已有代码执行时分配过多或过少的内存，在错误的偏移位置来读写数据。</p>
<h4 id="改变模版类的模版参数"><a href="#改变模版类的模版参数" class="headerlink" title="改变模版类的模版参数"></a>改变模版类的模版参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/ GCC mangling before: _Z3foo15MyTemplateClassIiE</span><br><span class="line"><span class="comment">//              after: _Z3foo15MyTemplateClassIivE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(MyTemplateClass&lt;<span class="keyword">int</span>&gt;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTemplateClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 = <span class="keyword">void</span>&gt;</span><br><span class="line">class MyTemplateClass</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因：与这个模板类型相关的函数，因为它的模板扩展改变也发生了变化。这会同时发生在函数（例如构造函数）以及将其作为参数的函数上。</p>
<h4 id="取消函数的导出"><a href="#取消函数的导出" class="headerlink" title="取消函数的导出"></a>取消函数的导出</h4><p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Q_CORE_EXPORT <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">qVersion</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">namespace</span> KSocketFactory </span><br><span class="line">&#123;</span><br><span class="line">true<span class="function">KDECORE_EXPORT QTcpSocket *<span class="title">connectToHost</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">qVersion</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> KSocketFactory </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QTcpSocket *<span class="title">connectToHost</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因：上面函数的符号没有加入到生成的库的导出符号列表中，因此其他库或应用不能看见它们。</p>
<h4 id="改为内联函数"><a href="#改为内联函数" class="headerlink" title="改为内联函数"></a>改为内联函数</h4><p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the following could be in a .cpp</span></span><br><span class="line"><span class="keyword">int</span> Math::square(<span class="keyword">int</span> n)</span><br><span class="line">&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the following could be in a .cpp</span></span><br><span class="line"><span class="keyword">int</span> Math::square(<span class="keyword">int</span> n)</span><br><span class="line">&#123; <span class="keyword">return</span> n * n; &#125;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the following could be in a .cpp</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Math::square(<span class="keyword">int</span> n)</span><br><span class="line">&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因：当一个函数被声明为内联，并且编译器在它的调用点内联它时，编译器就不需要发送一份离线拷贝（out-of-line copy）。存在并调用此函数的代码将无法再解析该函数。另外，在GCC用-fvisibiliinlines-hidden编译时，如果编译器确实发出了一份离线拷贝，那么它将被隐藏（不添加到导出的符号表中），因此不能从其他库中被访问。</p>
<h4 id="改变函数的参数"><a href="#改变函数的参数" class="headerlink" title="改变函数的参数"></a>改变函数的参数</h4><p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingii</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXHH@Z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingii</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXHH@Z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingRi</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXABH@Z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> &amp;i1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> i1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingPc</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXPAD@Z (32-bit)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingis</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXHF@Z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">short</span> i2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingiii</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXHHH@Z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> i3 = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingRKi</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXAAH@Z</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i1)</span></span>; <span class="comment">// breaks with Sun CC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z11doSomethingPKc</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?doSomething@@YAXPBD@Z (32-bit)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>原因：改变一个函数的参数（添加新的或改变现有的）改变了这个函数的名称。这是因为C++允许函数通过具有相同修饰别名，但稍微不同的参数来实现重载的机制所决定的。<br>上面的示例在SunCC中，没有一个修饰别名，编译器在声明和实现中都强制执行了一致的<a href="https://baike.baidu.com/item/pod/13976179" target="_blank" rel="noopener">POD</a>类型。</p>
<h4 id="改变返回类型"><a href="#改变返回类型" class="headerlink" title="改变返回类型"></a>改变返回类型</h4><p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCC mangling: _Z8positionv</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?position@@YA_JXZ</span></span><br><span class="line"><span class="function">qint64 <span class="title">position</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z4namev</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?position@@YAVQByteArray@@DXZ</span></span><br><span class="line"><span class="function">QByteArray <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z4namev</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?position@@YAPBDXZ</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z12createDevicev</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?createDevice@@YAPAVQTcpSocket@@XZ</span></span><br><span class="line"><span class="function">QTcpSocket *<span class="title">createDevice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _ZNK10QByteArray2atEi</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?at@QByteArray@@QBA?BDH@Z</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> QByteArray::at(<span class="keyword">int</span>) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _ZN6QEvent17registerEventTypeEi</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?registerEventType@QEvent@@QAAXH@Z</span></span><br><span class="line"><span class="keyword">int</span> QEvent::registerEventType(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCC mangling: _Z8positionv</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?position@@YAHXZ</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">position</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z4namev</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?position@@YAVQString@@XZ</span></span><br><span class="line"><span class="function">QString <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z4namev</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?position@@YAVQString@@XZ</span></span><br><span class="line"><span class="function">QString <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _Z12createDevicev (unchanged)</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?createDevice@@YAPAVQIODevice@@XZ</span></span><br><span class="line"><span class="function">QIODevice *<span class="title">createDevice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _ZNK10QByteArray2atEi (unchanged)</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?at@QByteArray@@QBADH@Z</span></span><br><span class="line"><span class="keyword">char</span> QByteArray::at(<span class="keyword">int</span>) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC mangling: _ZN6QEvent17registerEventTypeEi (unchanged)</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?registerEventType@QEvent@@QAAXW4Type@V0@@@Z</span></span><br><span class="line">QEvent::Type QEvent::registerEventType(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>原因：更改返回类型会在一些编译器中改变函数名的名称（GCC明显没有对返回类型进行编码）。然而，即使修饰（mangling）没有改变，关于如何处理返回类型的约定也可能改变。<br>在上面的第一个例子中，返回类型从64位改为32位整型，这意味着在某些架构上，返回寄存器的上半部分可能包含垃圾。在第二个例子中，返回类型从QByteArray改为QString，这是两种不兼容的类型。<br>在第三个例子中，返回类型从一个简单的整数（<a href="https://baike.baidu.com/item/pod/13976179" target="_blank" rel="noopener">POD</a>）变成了QString——在这种情况下，编译器通常需要传递一个隐藏的隐式第一个参数，而这是不存在的。在这种情况下，由于试图引用不存在的隐式QString参数，调用该函数的现有代码很可能会崩溃。<br>第四例,返回类型变化从一种<a href="https://baike.baidu.com/item/pod/13976179" target="_blank" rel="noopener">POD</a>类型(int)到另一个(enum),这（枚举）也可以看作一个int。他们的调用次序在所有编译器中极有可能相同,然而符号名称的修饰改变了,这意味着调用将因为未知符号而失败。</p>
<h4 id="改变访问权限"><a href="#改变访问权限" class="headerlink" title="改变访问权限"></a>改变访问权限</h4><p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">true<span class="comment">// GCC mangling: _ZN7MyClass11doSomethingEv</span></span><br><span class="line">true<span class="comment">// MSVC mangling: ?doSomething@MyClass@@IAAXXZ</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// GCC mangling: _ZN7MyClass11doSomethingEv (unchanged)</span></span><br><span class="line">true<span class="comment">// MSVC mangling: ?doSomething@MyClass@@QAAXXZ</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因：一些编译器在其修饰别名中对函数的保护类型进行编码。</p>
<h4 id="改变成员函数的const限定符"><a href="#改变成员函数的const限定符" class="headerlink" title="改变成员函数的const限定符"></a>改变成员函数的const限定符</h4><p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// GCC mangling: _ZNK7MyClass9somethingEv</span></span><br><span class="line">true<span class="comment">// MSVC mangling: ?something@MyClass@QBAHXZ</span></span><br><span class="line">true<span class="function"><span class="keyword">int</span> <span class="title">something</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// GCC mangling: _ZN7MyClass9somethingEv</span></span><br><span class="line">true<span class="comment">// MSVC mangling: ?something@MyClass@QAAHXZ</span></span><br><span class="line">true<span class="function"><span class="keyword">int</span> <span class="title">something</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因：编译器将一个函数的常量（const）性编译进了函数的修饰别名中。他们这样做是因为C++标准允许通过修改常量修饰符来实现重载函数。</p>
<h4 id="改变全局数据类型"><a href="#改变全局数据类型" class="headerlink" title="改变全局数据类型"></a>改变全局数据类型</h4><p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCC mangling: data (undecorated)</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?data@@3HA</span></span><br><span class="line"><span class="keyword">int</span> data = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// GCC mangling: _ZN7MyClass4dataE</span></span><br><span class="line">true<span class="comment">// MSVC mangling: ?data@MyClass@@2HA</span></span><br><span class="line">true<span class="keyword">static</span> <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCC mangling: data (undecorated)</span></span><br><span class="line"><span class="comment">// MSVC mangling: ?data@@3FA</span></span><br><span class="line"><span class="keyword">short</span> data = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// GCC mangling: _ZN7MyClass4dataE</span></span><br><span class="line">true<span class="comment">// MSVC mangling: ?data@MyClass@@2FA</span></span><br><span class="line">true<span class="keyword">static</span> <span class="keyword">short</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因：一些编译器将全局数据的类型编译进其修饰别名中。特别要注意的是，一些编译器甚至会对在C中允许的简单数据类型进行处理，这意味着<code>extern &quot;C&quot;</code>限定符也会产生不同的影响。<br>即使“mangling”没有改变，改变类型也会改变数据的大小。这意味着访问全局数据的代码可能访问太多或太少字节。</p>
<h4 id="改变全局数据的const限定符"><a href="#改变全局数据的const限定符" class="headerlink" title="改变全局数据的const限定符"></a>改变全局数据的const限定符</h4><p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MSVC mangling: ?data@@3HA</span></span><br><span class="line"><span class="keyword">int</span> data = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// MSVC mangling: ?data@MyClass@@2HA</span></span><br><span class="line">true<span class="keyword">static</span> <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">static</span> <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MSVC mangling: ?data@@3HB</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> data = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// MSVC mangling: ?data@MyClass@@2HB</span></span><br><span class="line">true<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="comment">// the compiler won't even create a symbol</span></span><br><span class="line">true<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> data = <span class="number">42</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因：一些编译器将全局数据的const限定符编码进了其修饰别名中。特别要注意的是，在类本身中声明的静态const值可以考虑为“内联”——也就是说，编译器不需要为值生成外部符号，因为所有的实现都肯定知道它。<br>即使对于那些没有对全局数据的const限定符进行编码的编译器，添加const也可能使编译器将该变量放置在只读的内存段中。试图写入的代码很可能会崩溃。</p>
<h4 id="将虚函数添加到类中"><a href="#将虚函数添加到类中" class="headerlink" title="将虚函数添加到类中"></a>将虚函数添加到类中</h4><p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="keyword">int</span> i;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">j</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因：没有任何虚拟成员或基础的类肯定与C结构完全相同，这是因为它与该语言的兼容性（即<a href="https://baike.baidu.com/item/pod/13976179" target="_blank" rel="noopener">POD</a>结构）。在一些编译器上，他们以及基于其的结构体（类）也是<a href="https://baike.baidu.com/item/pod/13976179" target="_blank" rel="noopener">POD</a>结构。然而，只要有一个虚基或虚成员函数，编译器就可以自由地以C++的方式排列结构，这通常意味着在结构的开始或结束时插入一个隐藏的指针，指向该类的虚拟表（virtual table）。这就改变了结构中元素的大小和偏移量。</p>
<h4 id="在非叶子类中添加新的虚函数"><a href="#在非叶子类中添加新的虚函数" class="headerlink" title="在非叶子类中添加新的虚函数"></a>在非叶子类中添加新的虚函数</h4><p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">virtual</span> ~MyClass();</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">virtual</span> ~MyClass();</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因:在一个非末端的类(也就是说,至少有一个类派生从这个类)中添加一个新的虚函数，改变了虚拟表的布局(虚拟表基本上是一个函数指针列表,指向在这类级别活跃的函数)。为了适应新的虚函数，编译器必须向该表添加一个新条目，但是现有的派生类不会知道它，也不会在它们的虚拟表中包含条目。</p>
<h4 id="改变虚函数声明的顺序"><a href="#改变虚函数声明的顺序" class="headerlink" title="改变虚函数声明的顺序"></a>改变虚函数声明的顺序</h4><p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">virtual</span> ~MyClass();</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">virtual</span> ~MyClass();</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因：编译器将指针放置到实现虚函数的函数中，按照它们在类中的声明顺序。通过改变声明的顺序，虚拟表中的条目的顺序也发生了变化。</p>
<p>注意：顺序是从父类继承的，所以覆盖一个虚函数，将会按照父类的顺序分配条目。</p>
<h4 id="覆盖一个非主基类的虚函数"><a href="#覆盖一个非主基类的虚函数" class="headerlink" title="覆盖一个非主基类的虚函数"></a>覆盖一个非主基类的虚函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">virtual</span> ~PrimaryBase();</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondaryBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="keyword">virtual</span> ~SecondaryBase();</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> PrimaryBase, <span class="keyword">public</span> SecondaryBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true~MyClass();</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> PrimaryBase, <span class="keyword">public</span> SecondaryBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true~MyClass();</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因：这是一个棘手的案例。当处理带有虚函数表的类的多重继承时，编译器必须创建多个虚表来保证多态性的工作（也就是说，当你的MyClass对象存储在PrimaryBase或中的基指针时）。主基类的虚表与该类的虚表共享，因为它们在开始时具有相同的布局。但是，如果你覆盖了来自非主基类的虚函数，它与添加一个新的虚函数是相同的，因为主基类中没有这个名称的虚函数。</p>
<p>注意：这适用于任何多继承的情况，即使它不是一个直接继承。在上面的例子中，如果我们用MyOtherClass从MyClass派生出来的，同样的约束也是适用的。</p>
<h4 id="使用具有不同顶部地址的协变（covariant）返回来覆盖虚函数"><a href="#使用具有不同顶部地址的协变（covariant）返回来覆盖虚函数" class="headerlink" title="使用具有不同顶部地址的协变（covariant）返回来覆盖虚函数"></a>使用具有不同顶部地址的协变（covariant）返回来覆盖虚函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data1</span> &#123;</span> <span class="keyword">int</span> i; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Data1 *<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data0</span> &#123;</span> <span class="keyword">int</span> i; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex1</span>:</span> Data0, Data1 &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex2</span>:</span> <span class="keyword">virtual</span> Data1 &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>改前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="function">Complex1 *<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span> <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="function">Complex2 *<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原因：这是另一个棘手的情况，比如上面的例子，也是出于同样的原因：编译器必须向虚表中添加第二个条目，就像添加了一个新的虚函数一样，这会改变虚表的布局并破坏派生类。<br>当从父类上覆盖一个虚函数返回与父类不同的类时，协变（covariant）调用就会发生（这是由C++标准所允许的，因此上面的代码是完全有效的，并且用BaseClass的p类型调用p-get（）将调用MyClass：：get）。如果像Complex1和Complex2一样，多派生的类型没有相同的顶部地址，那么编译器需要生成一个存根（stub）函数（通常称为“thunk”）来调整返回的指针的值。它将地址放在与其父在虚表中的虚函数对应的条目中。然而，它同时也返回新的顶部地址（top-address）来增加一个新的调用入口。</p>
<hr>
<h2 id="三、实际问题探索"><a href="#三、实际问题探索" class="headerlink" title="三、实际问题探索"></a>三、实际问题探索</h2><h3 id="1-内核调外壳的情况分析"><a href="#1-内核调外壳的情况分析" class="headerlink" title="1.内核调外壳的情况分析"></a>1.内核调外壳的情况分析</h3><blockquote>
<p>首先问题是因为软件的新版本Bin文件夹中模块的一处函数被改动（加了一个默认参数），新版本Bin文件夹中模块随着新版地区的安装会覆盖已有的老版本dll，这样当老版本地区模块工作的时候，调用Bin文件夹中对应模块的函数并没有重编，这就造成了二进制兼容问题。</p>
</blockquote>
<h4 id="A）问题分析复现"><a href="#A）问题分析复现" class="headerlink" title="A）问题分析复现"></a>A）问题分析复现</h4><img src="/知识手记/二进制兼容性研究/内核调外壳.png" title="内核调外壳">
<p>原有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// outPutA 增加了一个默认参数 bChange</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>, <span class="keyword">bool</span> bChange = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先看复现问题情况的Demo，复现原有未改动时的调用情形：</p>
<img src="/知识手记/二进制兼容性研究/原组合.png" title="原有问题现象">
<p>接下来是有问题的改动方法的执行现象：</p>
<img src="/知识手记/二进制兼容性研究/加默认参数后.png" title="原有问题现象">
<p>用IDA分析工具查看编译出的dll文件，其修饰别名以及对应的偏移信息：</p>
<p>原有</p>
<img src="/知识手记/二进制兼容性研究/原组合修饰别名及偏移信息.png" title="原组合修饰别名及偏移信息">
<p>改后</p>
<img src="/知识手记/二进制兼容性研究/加默认参数后的修饰别名及偏移信息.png" title="加默认参数后的修饰别名及偏移信息">
<p>我们可以看出，前后两个dll在<code>outputA</code>函数的修饰别名已经不一样了，同时看后面的解析信息，改后参数已经加了一个bool类型的参数。</p>
<p>我们再看调用dll的EXE文件的对应信息（未重编）：</p>
<img src="/知识手记/二进制兼容性研究/EXE的修饰别名及偏移信息.png" title="EXE的修饰别名及偏移信息">
<p>可见，exe文件中存的dll信息还是维持了原有版本的内容（很显然是这样的），这样当新版本覆盖了旧版dll文件以后，exe调用时便找不到对应的链接库位置，无法正常运行了。</p>
<p> <strong>这也就是上面说到的错误做法中的【改变函数的参数】里面增加默认参数这种情况，也是一定要注意避免的一种情况。</strong></p>
<h4 id="B）多种修改情况的探索"><a href="#B）多种修改情况的探索" class="headerlink" title="B）多种修改情况的探索"></a>B）多种修改情况的探索</h4><blockquote>
<p>问题出现了，那么我们怎么去修改它，能够达到既能维持二进制兼容性，又能最大限度地减少改动影响呢？</p>
</blockquote>
<p>显然在原有函数上直接加参数来实现目的的方法是不可行了，那么大概还可以通过下面几种情况来实现原有目的：</p>
<h5 id="Ⅰ-增加不同名多一个默认参数的函数被原函数调用"><a href="#Ⅰ-增加不同名多一个默认参数的函数被原函数调用" class="headerlink" title="Ⅰ.增加不同名多一个默认参数的函数被原函数调用"></a>Ⅰ.增加不同名多一个默认参数的函数被原函数调用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 新增了一个不同名函数来实现目的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutC</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>, <span class="keyword">bool</span> bChange = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutA : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原函数调用了新增函数</span></span><br><span class="line">    outPutC(i, strName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseDll::outPutC(<span class="keyword">int</span> i, QString strName, <span class="keyword">bool</span> bChange)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutC : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; bChange &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<img src="/知识手记/二进制兼容性研究/增加不同名多一个默认参数的函数被原函数调用.png" title="增加不同名多一个默认参数的函数被原函数调用">
<p>显然，原有EXE文件里面并没有新增函数的信息，调用dll中原有函数走到新增的函数时，便出现异常终止运行。</p>
<h5 id="Ⅱ-增加不同名多一个默认参数的函数不被原函数调用"><a href="#Ⅱ-增加不同名多一个默认参数的函数不被原函数调用" class="headerlink" title="Ⅱ.增加不同名多一个默认参数的函数不被原函数调用"></a>Ⅱ.增加不同名多一个默认参数的函数不被原函数调用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 新增了一个不同名函数来实现目的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutC</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>, <span class="keyword">bool</span> bChange = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutA : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseDll::outPutC(<span class="keyword">int</span> i, QString strName, <span class="keyword">bool</span> bChange)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutC : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; bChange &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<img src="/知识手记/二进制兼容性研究/增加不同名多一个默认参数的函数不被原函数调用.png" title="增加不同名多一个默认参数的函数不被原函数调用">
<p>可见，原有函数不论参数，顺序还是执行内容都没有被改动，所以执行情况正常，能够实现二进制兼容。</p>
<h5 id="Ⅲ-增加多一个默认参数被调用的同名函数"><a href="#Ⅲ-增加多一个默认参数被调用的同名函数" class="headerlink" title="Ⅲ.增加多一个默认参数被调用的同名函数"></a>Ⅲ.增加多一个默认参数被调用的同名函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 新增同名函数来实现目的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>, <span class="keyword">bool</span> bChange = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutA : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原函数调用新增函数</span></span><br><span class="line">    outPutA(i, strName, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName, <span class="keyword">bool</span> bChange)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutC : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; bChange &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<img src="/知识手记/二进制兼容性研究/增加多一个默认参数被调用的同名函数.png" title="增加多一个默认参数被调用的同名函数">
<p>根据程序输出情况，可见EXE调用原有函数，执行到调用新增同名函数时，由于没有新增函数的修饰别名和偏移信息，出现了循环调用自己的情况。</p>
<h5 id="Ⅳ-增加多一个默认参数不被调用的同名函数"><a href="#Ⅳ-增加多一个默认参数不被调用的同名函数" class="headerlink" title="Ⅳ.增加多一个默认参数不被调用的同名函数"></a>Ⅳ.增加多一个默认参数不被调用的同名函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 新增一个同名函数来实现目的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>, <span class="keyword">bool</span> bChange = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutA : "</span> &lt;&lt; i &lt;&lt; strName&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName, <span class="keyword">bool</span> bChange)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutC : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; bChange &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<img src="/知识手记/二进制兼容性研究/增加多一个默认参数不被调用的同名函数.png" title="增加多一个默认参数不被调用的同名函数">
<p>可见，因为两个函数内部没有相互影响，但具有相同的调用特征，由于原EXE并没有新函数的信息，所以新增函数并不会对两者间的二进制兼容造成影响：</p>
<ul>
<li>函数能正常调用</li>
<li>IDE的代码界面提示调用函数，接口存在歧义</li>
<li>重编调用EXE模块，编译不通过</li>
</ul>
<p>虽然这样不影响模块间的二进制兼容，但最好还是不要这样做。（会影响重编时的代码兼容性）</p>
<h5 id="Ⅴ-增加多一个普通参数被调用的同名函数"><a href="#Ⅴ-增加多一个普通参数被调用的同名函数" class="headerlink" title="Ⅴ.增加多一个普通参数被调用的同名函数"></a>Ⅴ.增加多一个普通参数被调用的同名函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 新增一个同名非默认参数来实现目的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">bool</span> bChange, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutA : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原函数调用新增函数</span></span><br><span class="line">    outPutA(i, <span class="literal">false</span>, strName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, <span class="keyword">bool</span> bChange, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutC : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; bChange &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<img src="/知识手记/二进制兼容性研究/增加多一个普通参数被调用的同名函数.png" title="增加多一个普通参数被调用的同名函数">
<p>这种情况与上面相近，EXE调用原有函数，走到调用新增函数的位置，识别成了调用原有函数自身。会将第二个参数转换为原函数的第二个参数（bool-&gt;String） ，转换出现异常，程序崩溃。</p>
<h5 id="Ⅵ-增加多一个普通参数不被调用的同名函数"><a href="#Ⅵ-增加多一个普通参数不被调用的同名函数" class="headerlink" title="Ⅵ.增加多一个普通参数不被调用的同名函数"></a>Ⅵ.增加多一个普通参数不被调用的同名函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBaseDll</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">(QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 新增一个同名非默认参数函数来实现目的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">bool</span> bChange, QString strName = <span class="string">"IBaseDll"</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutA : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseDll::outPutA(<span class="keyword">int</span> i, <span class="keyword">bool</span> bChange, QString strName)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"outPutC : "</span> &lt;&lt; i &lt;&lt; strName &lt;&lt; bChange &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<img src="/知识手记/二进制兼容性研究/增加多一个普通参数不被调用的同名函数.png" title="增加多一个普通参数不被调用的同名函数">
<p>这种情况，原有函数没有调用新增函数，EXE执行时没有出现异常，二进制兼容能够得到保证；但是这样就违背了增加默认参数的初衷，适用场景被受到了限制。</p>
<h3 id="2-外壳调内核的情况分析"><a href="#2-外壳调内核的情况分析" class="headerlink" title="2.外壳调内核的情况分析"></a>2.外壳调内核的情况分析</h3><h4 id="A）问题场景"><a href="#A）问题场景" class="headerlink" title="A）问题场景"></a>A）问题场景</h4><p>同上面情况刚好相反，当出现外壳调用内核的场景时。往往会出现外壳多地区通用，而各地区内核版本不同的情形，这时候如何保证同一个外壳与多个版本的内核兼容就是需要考虑的问题了。</p>
<p>简而言之，当外壳与内核版本A调用时，执行我们希望的A方法；当与另一个版本B调用时，又能够正确的调用B对应的方法。</p>
<h4 id="B）方法探索"><a href="#B）方法探索" class="headerlink" title="B）方法探索"></a>B）方法探索</h4><p>这里我们采取的方法是，在外壳中做多一层级的接口集成，通过共有父接口，派生出接口A和B；同时不同版本的方法在其基础上派生出来，这样同一个方法在不同版本中会有不同的父接口A或B。调用的时候通过父接口实例化对象，判断动态转换为子接口的情况来分别调用对应的方法，达到上面场景的兼容目的。</p>
<img src="/知识手记/二进制兼容性研究/外壳调内核.png" title="外壳调内核">
<p>以下是代码情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外壳实现位置</span></span><br><span class="line"></span><br><span class="line">DllTest::DllTest()</span><br><span class="line">&#123;</span><br><span class="line">    m_pBaseDll = <span class="keyword">new</span> BaseDll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DllTest::dllOutPut()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">dynamic_cast</span>&lt;IDllA*&gt;(m_pBaseDll))</span><br><span class="line">    &#123;</span><br><span class="line">        IDllA* dllA = <span class="keyword">dynamic_cast</span>&lt;IDllA*&gt;(m_pBaseDll);</span><br><span class="line">        dllA-&gt;outPut();</span><br><span class="line">        dllA-&gt;outPutA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">dynamic_cast</span>&lt;IDllB*&gt;(m_pBaseDll))</span><br><span class="line">    &#123;</span><br><span class="line">        IDllB* dllB = <span class="keyword">dynamic_cast</span>&lt;IDllB*&gt;(m_pBaseDll);</span><br><span class="line">        dllB-&gt;outPut();</span><br><span class="line">        dllB-&gt;outPutB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内核实现位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDllA</span> :</span> <span class="keyword">public</span> IBaseDll</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~IDllA() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDllB</span> :</span> <span class="keyword">public</span> IBaseDll</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~IDllB() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">declspec</span>(<span class="title">export</span>) <span class="title">BaseDll</span> :</span> <span class="keyword">public</span> IDllB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BaseDll();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IBaseDll interface</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPut</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">outPutB</span><span class="params">()</span> override</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当继承A接口时：</p>
<img src="/知识手记/二进制兼容性研究/外壳调内核A.png" title="外壳调内核A">
<p>当继承B接口时：</p>
<img src="/知识手记/二进制兼容性研究/外壳调内核B.png" title="外壳调内核B">
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>两种情况比较好的方案分别为：<ul>
<li>内核调外壳：增加不同名多一个默认参数的函数不被原函数调用</li>
<li>外壳调内核：判断动态转换派生的不同接口来判断该调用的方法</li>
</ul>
</li>
<li>另外：<ul>
<li>接口给了默认参数的情况下，继承函数不必再重复给默认参数，调用位置如果不给该参数传值，函数将优先采用接口参数，继承参数并不会起作用（某些IDE(Clion、VS等)中会在代码处给出警告提示）</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong><em>参考文章:</em></strong></p>
<ul>
<li><a href="https://events.static.linuxfound.org/sites/events/files/slides/Binary_Compatibility_for_library_devs.pdf" target="_blank" rel="noopener">_Binary_Compatibility_for_library_devs_</a> </li>
<li><a href="https://community.kde.org/Policies/Binary_Compatibility_Issues_With_C%2B%2B" target="_blank" rel="noopener"><em>Binary Compatibility Issues With C++</em></a></li>
<li><a href="https://community.kde.org/Policies/Binary_Compatibility_Examples" target="_blank" rel="noopener">_Binary_Compatibility_Examples_</a> </li>
</ul>
</blockquote>
</div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="http://yalei.wang/知识手记/二进制兼容性研究.html" data-id="cjsor99k6000c1gjjygobidfx" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACIUlEQVR42u3aQY6EMAwEQP7/afYBo43aNhxIKqcRYiDFwbJjX1e87p/1ez25//ee//51vbEwMDA+y7iXK3lBsqH/7kl+r/eGgYFxDmO9uTwIJiG4eiX5cBgYGBi930nKmAdiDAwMjAljnVD2qlEMDAyMXhHbK1zzY7X1Ex6rxTEwMD7ImATBt3+/0t/AwMD4FOMuroS33sT6Ob2FgYGxNyMPcOtkcZ3M5UMbk/1gYGCcw+gVlvmhf0LtlbsYGBi7MqojFJP0rlqBFgpdDAyMAxhJAJ0c9CethTy5xMDAOJORH43lzcX50VvhUA8DA+MYxnzEIS+G5wdtVy9yY2BgfJYxSsuC69XRimqbAQMD4xxGtTSdNB2fbT9gYGDszZg3AHqbmJTQSZKKgYGxE2MScHvbTe5cv/GBWI6BgfFBRlJM5iEy30q1XRrNjGBgYGzH6DUjJ4E4f281PcXAwNiVMWkA9FqezeOzdR6IgYGxNePZo/k8aOZJZLMlgIGBsR2j+rj5hnJe4QkYGBiHMfJjr+pwWP4hqkgMDIwTGJND/OrnqH6a6DNhYGBsyriLqxci84DbHCnDwMDYmvFGAlclVY/brsnCwMD4LOPZ2Y0kicxTTAwMDIw8FCYla7XNUB2zKNfiGBgYBzN6QxJ5EVtNJTEwMDCScJkEx+qwRR6sMTAwzmHkzYA8vE4SvtHMCAYGxnaM6mtyZHJ9Mn6BgYFxAOMPPy0i4H4pSncAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/C/">C++</a><a href="/tags/二进制兼容/">二进制兼容</a><a href="/tags/Binary-Compatibility/">Binary Compatibility</a></div><div class="post-nav"><a class="pre" href="/知识手记/Win10PowerShell集成包管理功能.html">win10集成多个源的powershell包管理功能</a><a class="next" href="/知识手记/C++子类动态转父类同名函数的调用问题.html">C++子类动态转父类同名函数的调用问题</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=1.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=1.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'd4a3a3f27e39eb0b95ca',
  clientSecret: '9678de603edba28128c4f1f4dc13c32e47323705',
  repo: 'rean1030.github.io',
  owner: 'rean1030',
  admin: ['rean1030'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/个人随笔/">个人随笔</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/知识手记/">知识手记</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/精选文摘/">精选文摘</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/二进制兼容/" style="font-size: 15px;">二进制兼容</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/重写/" style="font-size: 15px;">重写</a> <a href="/tags/Win10/" style="font-size: 15px;">Win10</a> <a href="/tags/PowerShell/" style="font-size: 15px;">PowerShell</a> <a href="/tags/Chocolatey/" style="font-size: 15px;">Chocolatey</a> <a href="/tags/QtCreator/" style="font-size: 15px;">QtCreator</a> <a href="/tags/代码字体/" style="font-size: 15px;">代码字体</a> <a href="/tags/中文字体/" style="font-size: 15px;">中文字体</a> <a href="/tags/CSharp/" style="font-size: 15px;">CSharp</a> <a href="/tags/软件/" style="font-size: 15px;">软件</a> <a href="/tags/线程/" style="font-size: 15px;">线程</a> <a href="/tags/MFC/" style="font-size: 15px;">MFC</a> <a href="/tags/CTreeCtrl/" style="font-size: 15px;">CTreeCtrl</a> <a href="/tags/GetItemData/" style="font-size: 15px;">GetItemData</a> <a href="/tags/个人域名/" style="font-size: 15px;">个人域名</a> <a href="/tags/个人博客/" style="font-size: 15px;">个人博客</a> <a href="/tags/域名邮箱/" style="font-size: 15px;">域名邮箱</a> <a href="/tags/个人网站/" style="font-size: 15px;">个人网站</a> <a href="/tags/隐藏/" style="font-size: 15px;">隐藏</a> <a href="/tags/Binary-Compatibility/" style="font-size: 15px;">Binary Compatibility</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/IE/" style="font-size: 15px;">IE</a> <a href="/tags/软件游戏登陆失败/" style="font-size: 15px;">软件游戏登陆失败</a> <a href="/tags/大鱼/" style="font-size: 15px;">大鱼</a> <a href="/tags/人生/" style="font-size: 15px;">人生</a> <a href="/tags/影评/" style="font-size: 15px;">影评</a> <a href="/tags/徐洪慈/" style="font-size: 15px;">徐洪慈</a> <a href="/tags/网易人间/" style="font-size: 15px;">网易人间</a> <a href="/tags/传记/" style="font-size: 15px;">传记</a> <a href="/tags/爱情/" style="font-size: 15px;">爱情</a> <a href="/tags/回忆/" style="font-size: 15px;">回忆</a> <a href="/tags/诗歌/" style="font-size: 15px;">诗歌</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/Gitalk/" style="font-size: 15px;">Gitalk</a> <a href="/tags/Error-Validation-Failed/" style="font-size: 15px;">Error Validation Failed</a> <a href="/tags/Office/" style="font-size: 15px;">Office</a> <a href="/tags/恢复预装/" style="font-size: 15px;">恢复预装</a> <a href="/tags/永久激活/" style="font-size: 15px;">永久激活</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/知识手记/Win10PowerShell集成包管理功能.html">win10集成多个源的powershell包管理功能</a></li><li class="post-list-item"><a class="post-list-link" href="/知识手记/二进制兼容性研究.html">二进制兼容性研究</a></li><li class="post-list-item"><a class="post-list-link" href="/知识手记/C++子类动态转父类同名函数的调用问题.html">C++子类动态转父类同名函数的调用问题</a></li><li class="post-list-item"><a class="post-list-link" href="/知识手记/博客中依赖Github评论功能的 Error Validation Failed 错误解决方法.html">博客中依赖Github评论功能的 Error Validation Failed 错误解决方法</a></li><li class="post-list-item"><a class="post-list-link" href="/个人随笔/忆往秋.html">忆往秋</a></li><li class="post-list-item"><a class="post-list-link" href="/知识手记/QtCreator设置英文字体之外的中文备选字体.html">QtCreator设置英文字体之外的中文备选字体</a></li><li class="post-list-item"><a class="post-list-link" href="/知识手记/重装系统后恢复电脑未激活的预装office软件.html">重装系统后恢复电脑未激活的预装office软件</a></li><li class="post-list-item"><a class="post-list-link" href="/知识手记/MFC中CtreeCtrl获取树节点数据的指针转换问题.html">MFC中CtreeCtrl获取树节点数据的指针转换问题</a></li><li class="post-list-item"><a class="post-list-link" href="/知识手记/解决一些软件无法登陆上网的问题.html">解决IE不能上网导致的一些软件无法登陆上网等问题</a></li><li class="post-list-item"><a class="post-list-link" href="/知识手记/CSharp使用独立线程函数结束阻塞对话窗体.html">CSharp使用独立线程函数结束阻塞对话窗体</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/Rean1030/" title="Github" target="_blank">Github</a><ul></ul><a href="https://www.linkedin.com/in/rean1030/" title="Linkedin" target="_blank">Linkedin</a><ul></ul><a href="mailto:mail@yalei.wang" title="Mail" target="_blank">Mail</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">往 事.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>